/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var ogcparser;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * OGC Parser\n */\nmodule.exports = {\n  service: __webpack_require__(/*! ./src/service */ \"./src/service.js\"),\n  wmts: __webpack_require__(/*! ./src/wmts */ \"./src/wmts.js\"),\n  wms: __webpack_require__(/*! ./src/wms */ \"./src/wms.js\")\n};\n\n//# sourceURL=webpack://ogcparser/./index.js?");

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nmodule.exports = function (qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n      idx = x.indexOf(eq),\n      kstr,\n      vstr,\n      k,\n      v;\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n  return obj;\n};\n\n//# sourceURL=webpack://ogcparser/./node_modules/querystring/decode.js?");

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar stringifyPrimitive = function stringifyPrimitive(v) {\n  switch (_typeof(v)) {\n    case 'string':\n      return v;\n    case 'boolean':\n      return v ? 'true' : 'false';\n    case 'number':\n      return isFinite(v) ? v : '';\n    default:\n      return '';\n  }\n};\nmodule.exports = function (obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n  if (_typeof(obj) === 'object') {\n    return Object.keys(obj).map(function (k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function (v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n  }\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n};\n\n//# sourceURL=webpack://ogcparser/./node_modules/querystring/encode.js?");

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring/encode.js\");\n\n//# sourceURL=webpack://ogcparser/./node_modules/querystring/index.js?");

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n;\n(function (root) {\n  /** Detect free variables */\n  var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;\n  var freeModule = ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;\n  var freeGlobal = (typeof __webpack_require__.g === \"undefined\" ? \"undefined\" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g;\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n    root = freeGlobal;\n  }\n\n  /**\n   * The `punycode` object.\n   * @name punycode\n   * @type Object\n   */\n  var punycode,\n    /** Highest positive signed 32-bit float value */\n    maxInt = 2147483647,\n    // aka. 0x7FFFFFFF or 2^31-1\n\n    /** Bootstring parameters */\n    base = 36,\n    tMin = 1,\n    tMax = 26,\n    skew = 38,\n    damp = 700,\n    initialBias = 72,\n    initialN = 128,\n    // 0x80\n    delimiter = '-',\n    // '\\x2D'\n\n    /** Regular expressions */\n    regexPunycode = /^xn--/,\n    regexNonASCII = /[^\\x20-\\x7E]/,\n    // unprintable ASCII chars + non-ASCII chars\n    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n    // RFC 3490 separators\n\n    /** Error messages */\n    errors = {\n      'overflow': 'Overflow: input needs wider integers to process',\n      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n      'invalid-input': 'Invalid input'\n    },\n    /** Convenience shortcuts */\n    baseMinusTMin = base - tMin,\n    floor = Math.floor,\n    stringFromCharCode = String.fromCharCode,\n    /** Temporary variable */\n    key;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A generic error utility function.\n   * @private\n   * @param {String} type The error type.\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\n   */\n  function error(type) {\n    throw RangeError(errors[type]);\n  }\n\n  /**\n   * A generic `Array#map` utility function.\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} callback The function that gets called for every array\n   * item.\n   * @returns {Array} A new array of values returned by the callback function.\n   */\n  function map(array, fn) {\n    var length = array.length;\n    var result = [];\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n    return result;\n  }\n\n  /**\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\n   * addresses.\n   * @private\n   * @param {String} domain The domain name or email address.\n   * @param {Function} callback The function that gets called for every\n   * character.\n   * @returns {Array} A new string of characters returned by the callback\n   * function.\n   */\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + '@';\n      string = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n\n  /**\n   * Creates an array containing the numeric code points of each Unicode\n   * character in the string. While JavaScript uses UCS-2 internally,\n   * this function will convert a pair of surrogate halves (each of which\n   * UCS-2 exposes as separate characters) into a single code point,\n   * matching UTF-16.\n   * @see `punycode.ucs2.encode`\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n   * @memberOf punycode.ucs2\n   * @name decode\n   * @param {String} string The Unicode input string (UCS-2).\n   * @returns {Array} The new array of code points.\n   */\n  function ucs2decode(string) {\n    var output = [],\n      counter = 0,\n      length = string.length,\n      value,\n      extra;\n    while (counter < length) {\n      value = string.charCodeAt(counter++);\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // high surrogate, and there is a next character\n        extra = string.charCodeAt(counter++);\n        if ((extra & 0xFC00) == 0xDC00) {\n          // low surrogate\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // unmatched surrogate; only append this code unit, in case the next\n          // code unit is the high surrogate of a surrogate pair\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Creates a string based on an array of numeric code points.\n   * @see `punycode.ucs2.decode`\n   * @memberOf punycode.ucs2\n   * @name encode\n   * @param {Array} codePoints The array of numeric code points.\n   * @returns {String} The new Unicode string (UCS-2).\n   */\n  function ucs2encode(array) {\n    return map(array, function (value) {\n      var output = '';\n      if (value > 0xFFFF) {\n        value -= 0x10000;\n        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n        value = 0xDC00 | value & 0x3FF;\n      }\n      output += stringFromCharCode(value);\n      return output;\n    }).join('');\n  }\n\n  /**\n   * Converts a basic code point into a digit/integer.\n   * @see `digitToBasic()`\n   * @private\n   * @param {Number} codePoint The basic numeric code point value.\n   * @returns {Number} The numeric value of a basic code point (for use in\n   * representing integers) in the range `0` to `base - 1`, or `base` if\n   * the code point does not represent a value.\n   */\n  function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n      return codePoint - 22;\n    }\n    if (codePoint - 65 < 26) {\n      return codePoint - 65;\n    }\n    if (codePoint - 97 < 26) {\n      return codePoint - 97;\n    }\n    return base;\n  }\n\n  /**\n   * Converts a digit/integer into a basic code point.\n   * @see `basicToDigit()`\n   * @private\n   * @param {Number} digit The numeric value of a basic code point.\n   * @returns {Number} The basic code point whose value (when used for\n   * representing integers) is `digit`, which needs to be in the range\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n   * used; else, the lowercase form is used. The behavior is undefined\n   * if `flag` is non-zero and `digit` has no uppercase form.\n   */\n  function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  }\n\n  /**\n   * Bias adaptation function as per section 3.4 of RFC 3492.\n   * http://tools.ietf.org/html/rfc3492#section-3.4\n   * @private\n   */\n  function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for /* no initialization */\n    (; delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  }\n\n  /**\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n   * symbols.\n   * @memberOf punycode\n   * @param {String} input The Punycode string of ASCII-only symbols.\n   * @returns {String} The resulting string of Unicode symbols.\n   */\n  function decode(input) {\n    // Don't use UCS-2\n    var output = [],\n      inputLength = input.length,\n      out,\n      i = 0,\n      n = initialN,\n      bias = initialBias,\n      basic,\n      j,\n      index,\n      oldi,\n      w,\n      k,\n      digit,\n      t,\n      /** Cached calculation results */\n      baseMinusT;\n\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n      basic = 0;\n    }\n    for (j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 0x80) {\n        error('not-basic');\n      }\n      output.push(input.charCodeAt(j));\n    }\n\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n    for /* no final expression */\n    (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      for /* no condition */\n      (oldi = i, w = 1, k = base;; k += base) {\n        if (index >= inputLength) {\n          error('invalid-input');\n        }\n        digit = basicToDigit(input.charCodeAt(index++));\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error('overflow');\n        }\n        i += digit * w;\n        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n        if (digit < t) {\n          break;\n        }\n        baseMinusT = base - t;\n        if (w > floor(maxInt / baseMinusT)) {\n          error('overflow');\n        }\n        w *= baseMinusT;\n      }\n      out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0);\n\n      // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n      if (floor(i / out) > maxInt - n) {\n        error('overflow');\n      }\n      n += floor(i / out);\n      i %= out;\n\n      // Insert `n` at position `i` of the output\n      output.splice(i++, 0, n);\n    }\n    return ucs2encode(output);\n  }\n\n  /**\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\n   * Punycode string of ASCII-only symbols.\n   * @memberOf punycode\n   * @param {String} input The string of Unicode symbols.\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\n   */\n  function encode(input) {\n    var n,\n      delta,\n      handledCPCount,\n      basicLength,\n      bias,\n      j,\n      m,\n      q,\n      k,\n      t,\n      currentValue,\n      output = [],\n      /** `inputLength` will hold the number of code points in `input`. */\n      inputLength,\n      /** Cached calculation results */\n      handledCPCountPlusOne,\n      baseMinusT,\n      qMinusT;\n\n    // Convert the input in UCS-2 to Unicode\n    input = ucs2decode(input);\n\n    // Cache the length\n    inputLength = input.length;\n\n    // Initialize the state\n    n = initialN;\n    delta = 0;\n    bias = initialBias;\n\n    // Handle the basic code points\n    for (j = 0; j < inputLength; ++j) {\n      currentValue = input[j];\n      if (currentValue < 0x80) {\n        output.push(stringFromCharCode(currentValue));\n      }\n    }\n    handledCPCount = basicLength = output.length;\n\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n\n    // Finish the basic string - if it is not empty - with a delimiter\n    if (basicLength) {\n      output.push(delimiter);\n    }\n\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      for (m = maxInt, j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue >= n && currentValue < m) {\n          m = currentValue;\n        }\n      }\n\n      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n      // but guard against overflow\n      handledCPCountPlusOne = handledCPCount + 1;\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error('overflow');\n      }\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < n && ++delta > maxInt) {\n          error('overflow');\n        }\n        if (currentValue == n) {\n          // Represent delta as a generalized variable-length integer\n          for /* no condition */\n          (q = delta, k = base;; k += base) {\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (q < t) {\n              break;\n            }\n            qMinusT = q - t;\n            baseMinusT = base - t;\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n            q = floor(qMinusT / baseMinusT);\n          }\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n          delta = 0;\n          ++handledCPCount;\n        }\n      }\n      ++delta;\n      ++n;\n    }\n    return output.join('');\n  }\n\n  /**\n   * Converts a Punycode string representing a domain name or an email address\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n   * it doesn't matter if you call it on a string that has already been\n   * converted to Unicode.\n   * @memberOf punycode\n   * @param {String} input The Punycoded domain name or email address to\n   * convert to Unicode.\n   * @returns {String} The Unicode representation of the given Punycode\n   * string.\n   */\n  function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  }\n\n  /**\n   * Converts a Unicode string representing a domain name or an email address to\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\n   * i.e. it doesn't matter if you call it with a domain that's already in\n   * ASCII.\n   * @memberOf punycode\n   * @param {String} input The domain name or email address to convert, as a\n   * Unicode string.\n   * @returns {String} The Punycode representation of the given domain name or\n   * email address.\n   */\n  function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Define the public API */\n  punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    'version': '1.3.2',\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n\n  /** Expose `punycode` */\n  // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n  if ( true && _typeof(__webpack_require__.amdO) == 'object' && __webpack_require__.amdO) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return punycode;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (freeExports && freeModule) {\n    if (module.exports == freeExports) {\n      // in Node.js or RingoJS v0.8.0+\n      freeModule.exports = punycode;\n    } else {\n      // in Narwhal or RingoJS v0.7.0-\n      for (key in punycode) {\n        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n      }\n    }\n  } else {\n    // in Rhino or a web browser\n    root.punycode = punycode;\n  }\n})(this);\n\n//# sourceURL=webpack://ogcparser/./node_modules/url/node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/url/node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\nexports.Url = Url;\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n  portPattern = /:[0-9]*$/,\n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n  // RFC 2396: characters reserved for delimiting URLs.\n  // We actually just auto-escape these.\n  delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n  // RFC 2396: characters not allowed for various reasons.\n  unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = ['\\''].concat(unwise),\n  // Characters that are never ever allowed in a hostname.\n  // Note that any invalid chars are also handled, but these\n  // are the ones that are *expected* to be seen, so we fast-path\n  // them.\n  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n  hostEndingChars = ['/', '?', '#'],\n  hostnameMaxLen = 255,\n  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  unsafeProtocol = {\n    'javascript': true,\n    'javascript:': true\n  },\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    'javascript': true,\n    'javascript:': true\n  },\n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    'http': true,\n    'https': true,\n    'ftp': true,\n    'gopher': true,\n    'file': true,\n    'http:': true,\n    'https:': true,\n    'ftp:': true,\n    'gopher:': true,\n    'file:': true\n  },\n  querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring/index.js\");\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + _typeof(url));\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n    uSplit = url.split(splitter),\n    slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n  var protocol = this.protocol || '',\n    pathname = this.pathname || '',\n    hash = this.hash || '',\n    host = false,\n    query = '';\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n  var search = this.search || query && '?' + query || '';\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n  return protocol + host + pathname + search + hash;\n};\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\nUrl.prototype.resolveObject = function (relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n    removeAllDots = mustEndAbs,\n    srcPath = result.pathname && result.pathname.split('/') || [],\n    relPath = relative.pathname && relative.pathname.split('/') || [],\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n    srcPath.push('');\n  }\n  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n//# sourceURL=webpack://ogcparser/./node_modules/url/url.js?");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nmodule.exports = {\n  isString: function isString(arg) {\n    return typeof arg === 'string';\n  },\n  isObject: function isObject(arg) {\n    return _typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function isNull(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n};\n\n//# sourceURL=webpack://ogcparser/./node_modules/url/util.js?");

/***/ }),

/***/ "./node_modules/xmldom/dom-parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xmldom/dom-parser.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("function DOMParser(options) {\n  this.options = options || {\n    locator: {}\n  };\n}\nDOMParser.prototype.parseFromString = function (source, mimeType) {\n  var options = this.options;\n  var sax = new XMLReader();\n  var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\n  var errorHandler = options.errorHandler;\n  var locator = options.locator;\n  var defaultNSMap = options.xmlns || {};\n  var entityMap = {\n    'lt': '<',\n    'gt': '>',\n    'amp': '&',\n    'quot': '\"',\n    'apos': \"'\"\n  };\n  if (locator) {\n    domBuilder.setDocumentLocator(locator);\n  }\n  sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\n  sax.domBuilder = options.domBuilder || domBuilder;\n  if (/\\/x?html?$/.test(mimeType)) {\n    entityMap.nbsp = '\\xa0';\n    entityMap.copy = '\\xa9';\n    defaultNSMap[''] = 'http://www.w3.org/1999/xhtml';\n  }\n  defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';\n  if (source) {\n    sax.parse(source, defaultNSMap, entityMap);\n  } else {\n    sax.errorHandler.error(\"invalid doc source\");\n  }\n  return domBuilder.doc;\n};\nfunction buildErrorHandler(errorImpl, domBuilder, locator) {\n  if (!errorImpl) {\n    if (domBuilder instanceof DOMHandler) {\n      return domBuilder;\n    }\n    errorImpl = domBuilder;\n  }\n  var errorHandler = {};\n  var isCallback = errorImpl instanceof Function;\n  locator = locator || {};\n  function build(key) {\n    var fn = errorImpl[key];\n    if (!fn && isCallback) {\n      fn = errorImpl.length == 2 ? function (msg) {\n        errorImpl(key, msg);\n      } : errorImpl;\n    }\n    errorHandler[key] = fn && function (msg) {\n      fn('[xmldom ' + key + ']\\t' + msg + _locator(locator));\n    } || function () {};\n  }\n  build('warning');\n  build('error');\n  build('fatalError');\n  return errorHandler;\n}\n\n//console.log('#\\n\\n\\n\\n\\n\\n\\n####')\n/**\r\n * +ContentHandler+ErrorHandler\r\n * +LexicalHandler+EntityResolver2\r\n * -DeclHandler-DTDHandler \r\n * \r\n * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\r\n * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\r\n */\nfunction DOMHandler() {\n  this.cdata = false;\n}\nfunction position(locator, node) {\n  node.lineNumber = locator.lineNumber;\n  node.columnNumber = locator.columnNumber;\n}\n/**\r\n * @see org.xml.sax.ContentHandler#startDocument\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\r\n */\nDOMHandler.prototype = {\n  startDocument: function startDocument() {\n    this.doc = new DOMImplementation().createDocument(null, null, null);\n    if (this.locator) {\n      this.doc.documentURI = this.locator.systemId;\n    }\n  },\n  startElement: function startElement(namespaceURI, localName, qName, attrs) {\n    var doc = this.doc;\n    var el = doc.createElementNS(namespaceURI, qName || localName);\n    var len = attrs.length;\n    appendElement(this, el);\n    this.currentElement = el;\n    this.locator && position(this.locator, el);\n    for (var i = 0; i < len; i++) {\n      var namespaceURI = attrs.getURI(i);\n      var value = attrs.getValue(i);\n      var qName = attrs.getQName(i);\n      var attr = doc.createAttributeNS(namespaceURI, qName);\n      this.locator && position(attrs.getLocator(i), attr);\n      attr.value = attr.nodeValue = value;\n      el.setAttributeNode(attr);\n    }\n  },\n  endElement: function endElement(namespaceURI, localName, qName) {\n    var current = this.currentElement;\n    var tagName = current.tagName;\n    this.currentElement = current.parentNode;\n  },\n  startPrefixMapping: function startPrefixMapping(prefix, uri) {},\n  endPrefixMapping: function endPrefixMapping(prefix) {},\n  processingInstruction: function processingInstruction(target, data) {\n    var ins = this.doc.createProcessingInstruction(target, data);\n    this.locator && position(this.locator, ins);\n    appendElement(this, ins);\n  },\n  ignorableWhitespace: function ignorableWhitespace(ch, start, length) {},\n  characters: function characters(chars, start, length) {\n    chars = _toString.apply(this, arguments);\n    //console.log(chars)\n    if (chars) {\n      if (this.cdata) {\n        var charNode = this.doc.createCDATASection(chars);\n      } else {\n        var charNode = this.doc.createTextNode(chars);\n      }\n      if (this.currentElement) {\n        this.currentElement.appendChild(charNode);\n      } else if (/^\\s*$/.test(chars)) {\n        this.doc.appendChild(charNode);\n        //process xml\n      }\n\n      this.locator && position(this.locator, charNode);\n    }\n  },\n  skippedEntity: function skippedEntity(name) {},\n  endDocument: function endDocument() {\n    this.doc.normalize();\n  },\n  setDocumentLocator: function setDocumentLocator(locator) {\n    if (this.locator = locator) {\n      // && !('lineNumber' in locator)){\n      locator.lineNumber = 0;\n    }\n  },\n  //LexicalHandler\n  comment: function comment(chars, start, length) {\n    chars = _toString.apply(this, arguments);\n    var comm = this.doc.createComment(chars);\n    this.locator && position(this.locator, comm);\n    appendElement(this, comm);\n  },\n  startCDATA: function startCDATA() {\n    //used in characters() methods\n    this.cdata = true;\n  },\n  endCDATA: function endCDATA() {\n    this.cdata = false;\n  },\n  startDTD: function startDTD(name, publicId, systemId) {\n    var impl = this.doc.implementation;\n    if (impl && impl.createDocumentType) {\n      var dt = impl.createDocumentType(name, publicId, systemId);\n      this.locator && position(this.locator, dt);\n      appendElement(this, dt);\n    }\n  },\n  /**\r\n   * @see org.xml.sax.ErrorHandler\r\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\r\n   */\n  warning: function warning(error) {\n    console.warn('[xmldom warning]\\t' + error, _locator(this.locator));\n  },\n  error: function error(_error) {\n    console.error('[xmldom error]\\t' + _error, _locator(this.locator));\n  },\n  fatalError: function fatalError(error) {\n    console.error('[xmldom fatalError]\\t' + error, _locator(this.locator));\n    throw error;\n  }\n};\nfunction _locator(l) {\n  if (l) {\n    return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n  }\n}\nfunction _toString(chars, start, length) {\n  if (typeof chars == 'string') {\n    return chars.substr(start, length);\n  } else {\n    //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n    if (chars.length >= start + length || start) {\n      return new java.lang.String(chars, start, length) + '';\n    }\n    return chars;\n  }\n}\n\n/*\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\r\n * used method of org.xml.sax.ext.LexicalHandler:\r\n *  #comment(chars, start, length)\r\n *  #startCDATA()\r\n *  #endCDATA()\r\n *  #startDTD(name, publicId, systemId)\r\n *\r\n *\r\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\r\n *  #endDTD()\r\n *  #startEntity(name)\r\n *  #endEntity(name)\r\n *\r\n *\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\r\n * IGNORED method of org.xml.sax.ext.DeclHandler\r\n * \t#attributeDecl(eName, aName, type, mode, value)\r\n *  #elementDecl(name, model)\r\n *  #externalEntityDecl(name, publicId, systemId)\r\n *  #internalEntityDecl(name, value)\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\r\n * IGNORED method of org.xml.sax.EntityResolver2\r\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\r\n *  #resolveEntity(publicId, systemId)\r\n *  #getExternalSubset(name, baseURI)\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\r\n * IGNORED method of org.xml.sax.DTDHandler\r\n *  #notationDecl(name, publicId, systemId) {};\r\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\r\n */\n\"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\n  DOMHandler.prototype[key] = function () {\n    return null;\n  };\n});\n\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\nfunction appendElement(hander, node) {\n  if (!hander.currentElement) {\n    hander.doc.appendChild(node);\n  } else {\n    hander.currentElement.appendChild(node);\n  }\n} //appendChild and setAttributeNS are preformance key\n\n//if(typeof require == 'function'){\nvar XMLReader = (__webpack_require__(/*! ./sax */ \"./node_modules/xmldom/sax.js\").XMLReader);\nvar DOMImplementation = exports.DOMImplementation = __webpack_require__(/*! ./dom */ \"./node_modules/xmldom/dom.js\").DOMImplementation;\nexports.XMLSerializer = __webpack_require__(/*! ./dom */ \"./node_modules/xmldom/dom.js\").XMLSerializer;\nexports.DOMParser = DOMParser;\n//}\n\n//# sourceURL=webpack://ogcparser/./node_modules/xmldom/dom-parser.js?");

/***/ }),

/***/ "./node_modules/xmldom/dom.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/dom.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*\n * DOM Level 2\n * Object DOMException\n * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n */\n\nfunction copy(src, dest) {\n  for (var p in src) {\n    dest[p] = src[p];\n  }\n}\n/**\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n */\nfunction _extends(Class, Super) {\n  var pt = Class.prototype;\n  if (Object.create) {\n    var ppt = Object.create(Super.prototype);\n    pt.__proto__ = ppt;\n  }\n  if (!(pt instanceof Super)) {\n    var t = function t() {};\n    ;\n    t.prototype = Super.prototype;\n    t = new t();\n    copy(pt, t);\n    Class.prototype = pt = t;\n  }\n  if (pt.constructor != Class) {\n    if (typeof Class != 'function') {\n      console.error(\"unknow Class:\" + Class);\n    }\n    pt.constructor = Class;\n  }\n}\nvar htmlns = 'http://www.w3.org/1999/xhtml';\n// Node Types\nvar NodeType = {};\nvar ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\nvar ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\nvar TEXT_NODE = NodeType.TEXT_NODE = 3;\nvar CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\nvar ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\nvar ENTITY_NODE = NodeType.ENTITY_NODE = 6;\nvar PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE = NodeType.COMMENT_NODE = 8;\nvar DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\nvar DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\nvar DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\nvar NOTATION_NODE = NodeType.NOTATION_NODE = 12;\n\n// ExceptionCode\nvar ExceptionCode = {};\nvar ExceptionMessage = {};\nvar INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = \"Index size error\", 1);\nvar DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = \"DOMString size error\", 2);\nvar HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = \"Hierarchy request error\", 3);\nvar WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = \"Wrong document\", 4);\nvar INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = \"Invalid character\", 5);\nvar NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = \"No data allowed\", 6);\nvar NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = \"No modification allowed\", 7);\nvar NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = \"Not found\", 8);\nvar NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = \"Not supported\", 9);\nvar INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = \"Attribute in use\", 10);\n//level2\nvar INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = \"Invalid state\", 11);\nvar SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = \"Syntax error\", 12);\nvar INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = \"Invalid modification\", 13);\nvar NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = \"Invalid namespace\", 14);\nvar INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = \"Invalid access\", 15);\nfunction DOMException(code, message) {\n  if (message instanceof Error) {\n    var error = message;\n  } else {\n    error = this;\n    Error.call(this, ExceptionMessage[code]);\n    this.message = ExceptionMessage[code];\n    if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n  }\n  error.code = code;\n  if (message) this.message = this.message + \": \" + message;\n  return error;\n}\n;\nDOMException.prototype = Error.prototype;\ncopy(ExceptionCode, DOMException);\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n * The items in the NodeList are accessible via an integral index, starting from 0.\n */\nfunction NodeList() {}\n;\nNodeList.prototype = {\n  /**\n   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n   * @standard level1\n   */\n  length: 0,\n  /**\n   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n   * @standard level1\n   * @param index  unsigned long \n   *   Index into the collection.\n   * @return Node\n   * \tThe node at the indexth position in the NodeList, or null if that is not a valid index. \n   */\n  item: function item(index) {\n    return this[index] || null;\n  },\n  toString: function toString(isHTML, nodeFilter) {\n    for (var buf = [], i = 0; i < this.length; i++) {\n      serializeToString(this[i], buf, isHTML, nodeFilter);\n    }\n    return buf.join('');\n  }\n};\nfunction LiveNodeList(node, refresh) {\n  this._node = node;\n  this._refresh = refresh;\n  _updateLiveList(this);\n}\nfunction _updateLiveList(list) {\n  var inc = list._node._inc || list._node.ownerDocument._inc;\n  if (list._inc != inc) {\n    var ls = list._refresh(list._node);\n    //console.log(ls.length)\n    __set__(list, 'length', ls.length);\n    copy(ls, list);\n    list._inc = inc;\n  }\n}\nLiveNodeList.prototype.item = function (i) {\n  _updateLiveList(this);\n  return this[i];\n};\n_extends(LiveNodeList, NodeList);\n/**\n * \n * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.\n * NamedNodeMap objects in the DOM are live.\n * used for attributes or DocumentType entities \n */\nfunction NamedNodeMap() {}\n;\nfunction _findNodeIndex(list, node) {\n  var i = list.length;\n  while (i--) {\n    if (list[i] === node) {\n      return i;\n    }\n  }\n}\nfunction _addNamedNode(el, list, newAttr, oldAttr) {\n  if (oldAttr) {\n    list[_findNodeIndex(list, oldAttr)] = newAttr;\n  } else {\n    list[list.length++] = newAttr;\n  }\n  if (el) {\n    newAttr.ownerElement = el;\n    var doc = el.ownerDocument;\n    if (doc) {\n      oldAttr && _onRemoveAttribute(doc, el, oldAttr);\n      _onAddAttribute(doc, el, newAttr);\n    }\n  }\n}\nfunction _removeNamedNode(el, list, attr) {\n  //console.log('remove attr:'+attr)\n  var i = _findNodeIndex(list, attr);\n  if (i >= 0) {\n    var lastIndex = list.length - 1;\n    while (i < lastIndex) {\n      list[i] = list[++i];\n    }\n    list.length = lastIndex;\n    if (el) {\n      var doc = el.ownerDocument;\n      if (doc) {\n        _onRemoveAttribute(doc, el, attr);\n        attr.ownerElement = null;\n      }\n    }\n  } else {\n    throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));\n  }\n}\nNamedNodeMap.prototype = {\n  length: 0,\n  item: NodeList.prototype.item,\n  getNamedItem: function getNamedItem(key) {\n    //\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n    //\t\t\treturn null;\n    //\t\t}\n    //console.log()\n    var i = this.length;\n    while (i--) {\n      var attr = this[i];\n      //console.log(attr.nodeName,key)\n      if (attr.nodeName == key) {\n        return attr;\n      }\n    }\n  },\n  setNamedItem: function setNamedItem(attr) {\n    var el = attr.ownerElement;\n    if (el && el != this._ownerElement) {\n      throw new DOMException(INUSE_ATTRIBUTE_ERR);\n    }\n    var oldAttr = this.getNamedItem(attr.nodeName);\n    _addNamedNode(this._ownerElement, this, attr, oldAttr);\n    return oldAttr;\n  },\n  /* returns Node */\n  setNamedItemNS: function setNamedItemNS(attr) {\n    // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n    var el = attr.ownerElement,\n      oldAttr;\n    if (el && el != this._ownerElement) {\n      throw new DOMException(INUSE_ATTRIBUTE_ERR);\n    }\n    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n    _addNamedNode(this._ownerElement, this, attr, oldAttr);\n    return oldAttr;\n  },\n  /* returns Node */\n  removeNamedItem: function removeNamedItem(key) {\n    var attr = this.getNamedItem(key);\n    _removeNamedNode(this._ownerElement, this, attr);\n    return attr;\n  },\n  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\n  //for level2\n  removeNamedItemNS: function removeNamedItemNS(namespaceURI, localName) {\n    var attr = this.getNamedItemNS(namespaceURI, localName);\n    _removeNamedNode(this._ownerElement, this, attr);\n    return attr;\n  },\n  getNamedItemNS: function getNamedItemNS(namespaceURI, localName) {\n    var i = this.length;\n    while (i--) {\n      var node = this[i];\n      if (node.localName == localName && node.namespaceURI == namespaceURI) {\n        return node;\n      }\n    }\n    return null;\n  }\n};\n/**\n * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490\n */\nfunction DOMImplementation( /* Object */features) {\n  this._features = {};\n  if (features) {\n    for (var feature in features) {\n      this._features = features[feature];\n    }\n  }\n}\n;\nDOMImplementation.prototype = {\n  hasFeature: function hasFeature( /* string */feature, /* string */version) {\n    var versions = this._features[feature.toLowerCase()];\n    if (versions && (!version || version in versions)) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n  // Introduced in DOM Level 2:\n  createDocument: function createDocument(namespaceURI, qualifiedName, doctype) {\n    // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR\n    var doc = new Document();\n    doc.implementation = this;\n    doc.childNodes = new NodeList();\n    doc.doctype = doctype;\n    if (doctype) {\n      doc.appendChild(doctype);\n    }\n    if (qualifiedName) {\n      var root = doc.createElementNS(namespaceURI, qualifiedName);\n      doc.appendChild(root);\n    }\n    return doc;\n  },\n  // Introduced in DOM Level 2:\n  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {\n    // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR\n    var node = new DocumentType();\n    node.name = qualifiedName;\n    node.nodeName = qualifiedName;\n    node.publicId = publicId;\n    node.systemId = systemId;\n    // Introduced in DOM Level 2:\n    //readonly attribute DOMString        internalSubset;\n\n    //TODO:..\n    //  readonly attribute NamedNodeMap     entities;\n    //  readonly attribute NamedNodeMap     notations;\n    return node;\n  }\n};\n\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n */\n\nfunction Node() {}\n;\nNode.prototype = {\n  firstChild: null,\n  lastChild: null,\n  previousSibling: null,\n  nextSibling: null,\n  attributes: null,\n  parentNode: null,\n  childNodes: null,\n  ownerDocument: null,\n  nodeValue: null,\n  namespaceURI: null,\n  prefix: null,\n  localName: null,\n  // Modified in DOM Level 2:\n  insertBefore: function insertBefore(newChild, refChild) {\n    //raises \n    return _insertBefore(this, newChild, refChild);\n  },\n  replaceChild: function replaceChild(newChild, oldChild) {\n    //raises \n    this.insertBefore(newChild, oldChild);\n    if (oldChild) {\n      this.removeChild(oldChild);\n    }\n  },\n  removeChild: function removeChild(oldChild) {\n    return _removeChild(this, oldChild);\n  },\n  appendChild: function appendChild(newChild) {\n    return this.insertBefore(newChild, null);\n  },\n  hasChildNodes: function hasChildNodes() {\n    return this.firstChild != null;\n  },\n  cloneNode: function cloneNode(deep) {\n    return _cloneNode(this.ownerDocument || this, this, deep);\n  },\n  // Modified in DOM Level 2:\n  normalize: function normalize() {\n    var child = this.firstChild;\n    while (child) {\n      var next = child.nextSibling;\n      if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n        this.removeChild(next);\n        child.appendData(next.data);\n      } else {\n        child.normalize();\n        child = next;\n      }\n    }\n  },\n  // Introduced in DOM Level 2:\n  isSupported: function isSupported(feature, version) {\n    return this.ownerDocument.implementation.hasFeature(feature, version);\n  },\n  // Introduced in DOM Level 2:\n  hasAttributes: function hasAttributes() {\n    return this.attributes.length > 0;\n  },\n  lookupPrefix: function lookupPrefix(namespaceURI) {\n    var el = this;\n    while (el) {\n      var map = el._nsMap;\n      //console.dir(map)\n      if (map) {\n        for (var n in map) {\n          if (map[n] == namespaceURI) {\n            return n;\n          }\n        }\n      }\n      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n    }\n    return null;\n  },\n  // Introduced in DOM Level 3:\n  lookupNamespaceURI: function lookupNamespaceURI(prefix) {\n    var el = this;\n    while (el) {\n      var map = el._nsMap;\n      //console.dir(map)\n      if (map) {\n        if (prefix in map) {\n          return map[prefix];\n        }\n      }\n      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n    }\n    return null;\n  },\n  // Introduced in DOM Level 3:\n  isDefaultNamespace: function isDefaultNamespace(namespaceURI) {\n    var prefix = this.lookupPrefix(namespaceURI);\n    return prefix == null;\n  }\n};\nfunction _xmlEncoder(c) {\n  return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\n}\ncopy(NodeType, Node);\ncopy(NodeType, Node.prototype);\n\n/**\n * @param callback return true for continue,false for break\n * @return boolean true: break visit;\n */\nfunction _visitNode(node, callback) {\n  if (callback(node)) {\n    return true;\n  }\n  if (node = node.firstChild) {\n    do {\n      if (_visitNode(node, callback)) {\n        return true;\n      }\n    } while (node = node.nextSibling);\n  }\n}\nfunction Document() {}\nfunction _onAddAttribute(doc, el, newAttr) {\n  doc && doc._inc++;\n  var ns = newAttr.namespaceURI;\n  if (ns == 'http://www.w3.org/2000/xmlns/') {\n    //update namespace\n    el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n  }\n}\nfunction _onRemoveAttribute(doc, el, newAttr, remove) {\n  doc && doc._inc++;\n  var ns = newAttr.namespaceURI;\n  if (ns == 'http://www.w3.org/2000/xmlns/') {\n    //update namespace\n    delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n  }\n}\nfunction _onUpdateChild(doc, el, newChild) {\n  if (doc && doc._inc) {\n    doc._inc++;\n    //update childNodes\n    var cs = el.childNodes;\n    if (newChild) {\n      cs[cs.length++] = newChild;\n    } else {\n      //console.log(1)\n      var child = el.firstChild;\n      var i = 0;\n      while (child) {\n        cs[i++] = child;\n        child = child.nextSibling;\n      }\n      cs.length = i;\n    }\n  }\n}\n\n/**\n * attributes;\n * children;\n * \n * writeable properties:\n * nodeValue,Attr:value,CharacterData:data\n * prefix\n */\nfunction _removeChild(parentNode, child) {\n  var previous = child.previousSibling;\n  var next = child.nextSibling;\n  if (previous) {\n    previous.nextSibling = next;\n  } else {\n    parentNode.firstChild = next;\n  }\n  if (next) {\n    next.previousSibling = previous;\n  } else {\n    parentNode.lastChild = previous;\n  }\n  _onUpdateChild(parentNode.ownerDocument, parentNode);\n  return child;\n}\n/**\n * preformance key(refChild == null)\n */\nfunction _insertBefore(parentNode, newChild, nextChild) {\n  var cp = newChild.parentNode;\n  if (cp) {\n    cp.removeChild(newChild); //remove and update\n  }\n\n  if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    var newFirst = newChild.firstChild;\n    if (newFirst == null) {\n      return newChild;\n    }\n    var newLast = newChild.lastChild;\n  } else {\n    newFirst = newLast = newChild;\n  }\n  var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;\n  newFirst.previousSibling = pre;\n  newLast.nextSibling = nextChild;\n  if (pre) {\n    pre.nextSibling = newFirst;\n  } else {\n    parentNode.firstChild = newFirst;\n  }\n  if (nextChild == null) {\n    parentNode.lastChild = newLast;\n  } else {\n    nextChild.previousSibling = newLast;\n  }\n  do {\n    newFirst.parentNode = parentNode;\n  } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n  _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);\n  //console.log(parentNode.lastChild.nextSibling == null)\n  if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n    newChild.firstChild = newChild.lastChild = null;\n  }\n  return newChild;\n}\nfunction _appendSingleChild(parentNode, newChild) {\n  var cp = newChild.parentNode;\n  if (cp) {\n    var pre = parentNode.lastChild;\n    cp.removeChild(newChild); //remove and update\n    var pre = parentNode.lastChild;\n  }\n  var pre = parentNode.lastChild;\n  newChild.parentNode = parentNode;\n  newChild.previousSibling = pre;\n  newChild.nextSibling = null;\n  if (pre) {\n    pre.nextSibling = newChild;\n  } else {\n    parentNode.firstChild = newChild;\n  }\n  parentNode.lastChild = newChild;\n  _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\n  return newChild;\n  //console.log(\"__aa\",parentNode.lastChild.nextSibling == null)\n}\n\nDocument.prototype = {\n  //implementation : null,\n  nodeName: '#document',\n  nodeType: DOCUMENT_NODE,\n  doctype: null,\n  documentElement: null,\n  _inc: 1,\n  insertBefore: function insertBefore(newChild, refChild) {\n    //raises \n    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n      var child = newChild.firstChild;\n      while (child) {\n        var next = child.nextSibling;\n        this.insertBefore(child, refChild);\n        child = next;\n      }\n      return newChild;\n    }\n    if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {\n      this.documentElement = newChild;\n    }\n    return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;\n  },\n  removeChild: function removeChild(oldChild) {\n    if (this.documentElement == oldChild) {\n      this.documentElement = null;\n    }\n    return _removeChild(this, oldChild);\n  },\n  // Introduced in DOM Level 2:\n  importNode: function importNode(importedNode, deep) {\n    return _importNode(this, importedNode, deep);\n  },\n  // Introduced in DOM Level 2:\n  getElementById: function getElementById(id) {\n    var rtv = null;\n    _visitNode(this.documentElement, function (node) {\n      if (node.nodeType == ELEMENT_NODE) {\n        if (node.getAttribute('id') == id) {\n          rtv = node;\n          return true;\n        }\n      }\n    });\n    return rtv;\n  },\n  //document factory method:\n  createElement: function createElement(tagName) {\n    var node = new Element();\n    node.ownerDocument = this;\n    node.nodeName = tagName;\n    node.tagName = tagName;\n    node.childNodes = new NodeList();\n    var attrs = node.attributes = new NamedNodeMap();\n    attrs._ownerElement = node;\n    return node;\n  },\n  createDocumentFragment: function createDocumentFragment() {\n    var node = new DocumentFragment();\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    return node;\n  },\n  createTextNode: function createTextNode(data) {\n    var node = new Text();\n    node.ownerDocument = this;\n    node.appendData(data);\n    return node;\n  },\n  createComment: function createComment(data) {\n    var node = new Comment();\n    node.ownerDocument = this;\n    node.appendData(data);\n    return node;\n  },\n  createCDATASection: function createCDATASection(data) {\n    var node = new CDATASection();\n    node.ownerDocument = this;\n    node.appendData(data);\n    return node;\n  },\n  createProcessingInstruction: function createProcessingInstruction(target, data) {\n    var node = new ProcessingInstruction();\n    node.ownerDocument = this;\n    node.tagName = node.target = target;\n    node.nodeValue = node.data = data;\n    return node;\n  },\n  createAttribute: function createAttribute(name) {\n    var node = new Attr();\n    node.ownerDocument = this;\n    node.name = name;\n    node.nodeName = name;\n    node.localName = name;\n    node.specified = true;\n    return node;\n  },\n  createEntityReference: function createEntityReference(name) {\n    var node = new EntityReference();\n    node.ownerDocument = this;\n    node.nodeName = name;\n    return node;\n  },\n  // Introduced in DOM Level 2:\n  createElementNS: function createElementNS(namespaceURI, qualifiedName) {\n    var node = new Element();\n    var pl = qualifiedName.split(':');\n    var attrs = node.attributes = new NamedNodeMap();\n    node.childNodes = new NodeList();\n    node.ownerDocument = this;\n    node.nodeName = qualifiedName;\n    node.tagName = qualifiedName;\n    node.namespaceURI = namespaceURI;\n    if (pl.length == 2) {\n      node.prefix = pl[0];\n      node.localName = pl[1];\n    } else {\n      //el.prefix = null;\n      node.localName = qualifiedName;\n    }\n    attrs._ownerElement = node;\n    return node;\n  },\n  // Introduced in DOM Level 2:\n  createAttributeNS: function createAttributeNS(namespaceURI, qualifiedName) {\n    var node = new Attr();\n    var pl = qualifiedName.split(':');\n    node.ownerDocument = this;\n    node.nodeName = qualifiedName;\n    node.name = qualifiedName;\n    node.namespaceURI = namespaceURI;\n    node.specified = true;\n    if (pl.length == 2) {\n      node.prefix = pl[0];\n      node.localName = pl[1];\n    } else {\n      //el.prefix = null;\n      node.localName = qualifiedName;\n    }\n    return node;\n  }\n};\n_extends(Document, Node);\nfunction Element() {\n  this._nsMap = {};\n}\n;\nElement.prototype = {\n  nodeType: ELEMENT_NODE,\n  hasAttribute: function hasAttribute(name) {\n    return this.getAttributeNode(name) != null;\n  },\n  getAttribute: function getAttribute(name) {\n    var attr = this.getAttributeNode(name);\n    return attr && attr.value || '';\n  },\n  getAttributeNode: function getAttributeNode(name) {\n    return this.attributes.getNamedItem(name);\n  },\n  setAttribute: function setAttribute(name, value) {\n    var attr = this.ownerDocument.createAttribute(name);\n    attr.value = attr.nodeValue = \"\" + value;\n    this.setAttributeNode(attr);\n  },\n  removeAttribute: function removeAttribute(name) {\n    var attr = this.getAttributeNode(name);\n    attr && this.removeAttributeNode(attr);\n  },\n  //four real opeartion method\n  appendChild: function appendChild(newChild) {\n    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return this.insertBefore(newChild, null);\n    } else {\n      return _appendSingleChild(this, newChild);\n    }\n  },\n  setAttributeNode: function setAttributeNode(newAttr) {\n    return this.attributes.setNamedItem(newAttr);\n  },\n  setAttributeNodeNS: function setAttributeNodeNS(newAttr) {\n    return this.attributes.setNamedItemNS(newAttr);\n  },\n  removeAttributeNode: function removeAttributeNode(oldAttr) {\n    //console.log(this == oldAttr.ownerElement)\n    return this.attributes.removeNamedItem(oldAttr.nodeName);\n  },\n  //get real attribute name,and remove it by removeAttributeNode\n  removeAttributeNS: function removeAttributeNS(namespaceURI, localName) {\n    var old = this.getAttributeNodeNS(namespaceURI, localName);\n    old && this.removeAttributeNode(old);\n  },\n  hasAttributeNS: function hasAttributeNS(namespaceURI, localName) {\n    return this.getAttributeNodeNS(namespaceURI, localName) != null;\n  },\n  getAttributeNS: function getAttributeNS(namespaceURI, localName) {\n    var attr = this.getAttributeNodeNS(namespaceURI, localName);\n    return attr && attr.value || '';\n  },\n  setAttributeNS: function setAttributeNS(namespaceURI, qualifiedName, value) {\n    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n    attr.value = attr.nodeValue = \"\" + value;\n    this.setAttributeNode(attr);\n  },\n  getAttributeNodeNS: function getAttributeNodeNS(namespaceURI, localName) {\n    return this.attributes.getNamedItemNS(namespaceURI, localName);\n  },\n  getElementsByTagName: function getElementsByTagName(tagName) {\n    return new LiveNodeList(this, function (base) {\n      var ls = [];\n      _visitNode(base, function (node) {\n        if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {\n          ls.push(node);\n        }\n      });\n      return ls;\n    });\n  },\n  getElementsByTagNameNS: function getElementsByTagNameNS(namespaceURI, localName) {\n    return new LiveNodeList(this, function (base) {\n      var ls = [];\n      _visitNode(base, function (node) {\n        if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\n          ls.push(node);\n        }\n      });\n      return ls;\n    });\n  }\n};\nDocument.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\nDocument.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n_extends(Element, Node);\nfunction Attr() {}\n;\nAttr.prototype.nodeType = ATTRIBUTE_NODE;\n_extends(Attr, Node);\nfunction CharacterData() {}\n;\nCharacterData.prototype = {\n  data: '',\n  substringData: function substringData(offset, count) {\n    return this.data.substring(offset, offset + count);\n  },\n  appendData: function appendData(text) {\n    text = this.data + text;\n    this.nodeValue = this.data = text;\n    this.length = text.length;\n  },\n  insertData: function insertData(offset, text) {\n    this.replaceData(offset, 0, text);\n  },\n  appendChild: function appendChild(newChild) {\n    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);\n  },\n  deleteData: function deleteData(offset, count) {\n    this.replaceData(offset, count, \"\");\n  },\n  replaceData: function replaceData(offset, count, text) {\n    var start = this.data.substring(0, offset);\n    var end = this.data.substring(offset + count);\n    text = start + text + end;\n    this.nodeValue = this.data = text;\n    this.length = text.length;\n  }\n};\n_extends(CharacterData, Node);\nfunction Text() {}\n;\nText.prototype = {\n  nodeName: \"#text\",\n  nodeType: TEXT_NODE,\n  splitText: function splitText(offset) {\n    var text = this.data;\n    var newText = text.substring(offset);\n    text = text.substring(0, offset);\n    this.data = this.nodeValue = text;\n    this.length = text.length;\n    var newNode = this.ownerDocument.createTextNode(newText);\n    if (this.parentNode) {\n      this.parentNode.insertBefore(newNode, this.nextSibling);\n    }\n    return newNode;\n  }\n};\n_extends(Text, CharacterData);\nfunction Comment() {}\n;\nComment.prototype = {\n  nodeName: \"#comment\",\n  nodeType: COMMENT_NODE\n};\n_extends(Comment, CharacterData);\nfunction CDATASection() {}\n;\nCDATASection.prototype = {\n  nodeName: \"#cdata-section\",\n  nodeType: CDATA_SECTION_NODE\n};\n_extends(CDATASection, CharacterData);\nfunction DocumentType() {}\n;\nDocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n_extends(DocumentType, Node);\nfunction Notation() {}\n;\nNotation.prototype.nodeType = NOTATION_NODE;\n_extends(Notation, Node);\nfunction Entity() {}\n;\nEntity.prototype.nodeType = ENTITY_NODE;\n_extends(Entity, Node);\nfunction EntityReference() {}\n;\nEntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n_extends(EntityReference, Node);\nfunction DocumentFragment() {}\n;\nDocumentFragment.prototype.nodeName = \"#document-fragment\";\nDocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n_extends(DocumentFragment, Node);\nfunction ProcessingInstruction() {}\nProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n_extends(ProcessingInstruction, Node);\nfunction XMLSerializer() {}\nXMLSerializer.prototype.serializeToString = function (node, isHtml, nodeFilter) {\n  return nodeSerializeToString.call(node, isHtml, nodeFilter);\n};\nNode.prototype.toString = nodeSerializeToString;\nfunction nodeSerializeToString(isHtml, nodeFilter) {\n  var buf = [];\n  var refNode = this.nodeType == 9 ? this.documentElement : this;\n  var prefix = refNode.prefix;\n  var uri = refNode.namespaceURI;\n  if (uri && prefix == null) {\n    //console.log(prefix)\n    var prefix = refNode.lookupPrefix(uri);\n    if (prefix == null) {\n      //isHTML = true;\n      var visibleNamespaces = [{\n        namespace: uri,\n        prefix: null\n      }\n      //{namespace:uri,prefix:''}\n      ];\n    }\n  }\n\n  serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);\n  //console.log('###',this.nodeType,uri,prefix,buf.join(''))\n  return buf.join('');\n}\nfunction needNamespaceDefine(node, isHTML, visibleNamespaces) {\n  var prefix = node.prefix || '';\n  var uri = node.namespaceURI;\n  if (!prefix && !uri) {\n    return false;\n  }\n  if (prefix === \"xml\" && uri === \"http://www.w3.org/XML/1998/namespace\" || uri == 'http://www.w3.org/2000/xmlns/') {\n    return false;\n  }\n  var i = visibleNamespaces.length;\n  //console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)\n  while (i--) {\n    var ns = visibleNamespaces[i];\n    // get namespace prefix\n    //console.log(node.nodeType,node.tagName,ns.prefix,prefix)\n    if (ns.prefix == prefix) {\n      return ns.namespace != uri;\n    }\n  }\n  //console.log(isHTML,uri,prefix=='')\n  //if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){\n  //\treturn false;\n  //}\n  //node.flag = '11111'\n  //console.error(3,true,node.flag,node.prefix,node.namespaceURI)\n  return true;\n}\nfunction serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {\n  if (nodeFilter) {\n    node = nodeFilter(node);\n    if (node) {\n      if (typeof node == 'string') {\n        buf.push(node);\n        return;\n      }\n    } else {\n      return;\n    }\n    //buf.sort.apply(attrs, attributeSorter);\n  }\n\n  switch (node.nodeType) {\n    case ELEMENT_NODE:\n      if (!visibleNamespaces) visibleNamespaces = [];\n      var startVisibleNamespaces = visibleNamespaces.length;\n      var attrs = node.attributes;\n      var len = attrs.length;\n      var child = node.firstChild;\n      var nodeName = node.tagName;\n      isHTML = htmlns === node.namespaceURI || isHTML;\n      buf.push('<', nodeName);\n      for (var i = 0; i < len; i++) {\n        // add namespaces for attributes\n        var attr = attrs.item(i);\n        if (attr.prefix == 'xmlns') {\n          visibleNamespaces.push({\n            prefix: attr.localName,\n            namespace: attr.value\n          });\n        } else if (attr.nodeName == 'xmlns') {\n          visibleNamespaces.push({\n            prefix: '',\n            namespace: attr.value\n          });\n        }\n      }\n      for (var i = 0; i < len; i++) {\n        var attr = attrs.item(i);\n        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\n          var prefix = attr.prefix || '';\n          var uri = attr.namespaceURI;\n          var ns = prefix ? ' xmlns:' + prefix : \" xmlns\";\n          buf.push(ns, '=\"', uri, '\"');\n          visibleNamespaces.push({\n            prefix: prefix,\n            namespace: uri\n          });\n        }\n        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);\n      }\n      // add namespace for current node\t\t\n      if (needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n        var prefix = node.prefix || '';\n        var uri = node.namespaceURI;\n        var ns = prefix ? ' xmlns:' + prefix : \" xmlns\";\n        buf.push(ns, '=\"', uri, '\"');\n        visibleNamespaces.push({\n          prefix: prefix,\n          namespace: uri\n        });\n      }\n      if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {\n        buf.push('>');\n        //if is cdata child node\n        if (isHTML && /^script$/i.test(nodeName)) {\n          while (child) {\n            if (child.data) {\n              buf.push(child.data);\n            } else {\n              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);\n            }\n            child = child.nextSibling;\n          }\n        } else {\n          while (child) {\n            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);\n            child = child.nextSibling;\n          }\n        }\n        buf.push('</', nodeName, '>');\n      } else {\n        buf.push('/>');\n      }\n      // remove added visible namespaces\n      //visibleNamespaces.length = startVisibleNamespaces;\n      return;\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      var child = node.firstChild;\n      while (child) {\n        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);\n        child = child.nextSibling;\n      }\n      return;\n    case ATTRIBUTE_NODE:\n      return buf.push(' ', node.name, '=\"', node.value.replace(/[<&\"]/g, _xmlEncoder), '\"');\n    case TEXT_NODE:\n      return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));\n    case CDATA_SECTION_NODE:\n      return buf.push('<![CDATA[', node.data, ']]>');\n    case COMMENT_NODE:\n      return buf.push(\"<!--\", node.data, \"-->\");\n    case DOCUMENT_TYPE_NODE:\n      var pubid = node.publicId;\n      var sysid = node.systemId;\n      buf.push('<!DOCTYPE ', node.name);\n      if (pubid) {\n        buf.push(' PUBLIC \"', pubid);\n        if (sysid && sysid != '.') {\n          buf.push('\" \"', sysid);\n        }\n        buf.push('\">');\n      } else if (sysid && sysid != '.') {\n        buf.push(' SYSTEM \"', sysid, '\">');\n      } else {\n        var sub = node.internalSubset;\n        if (sub) {\n          buf.push(\" [\", sub, \"]\");\n        }\n        buf.push(\">\");\n      }\n      return;\n    case PROCESSING_INSTRUCTION_NODE:\n      return buf.push(\"<?\", node.target, \" \", node.data, \"?>\");\n    case ENTITY_REFERENCE_NODE:\n      return buf.push('&', node.nodeName, ';');\n    //case ENTITY_NODE:\n    //case NOTATION_NODE:\n    default:\n      buf.push('??', node.nodeName);\n  }\n}\nfunction _importNode(doc, node, deep) {\n  var node2;\n  switch (node.nodeType) {\n    case ELEMENT_NODE:\n      node2 = node.cloneNode(false);\n      node2.ownerDocument = doc;\n    //var attrs = node2.attributes;\n    //var len = attrs.length;\n    //for(var i=0;i<len;i++){\n    //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n    //}\n    case DOCUMENT_FRAGMENT_NODE:\n      break;\n    case ATTRIBUTE_NODE:\n      deep = true;\n      break;\n    //case ENTITY_REFERENCE_NODE:\n    //case PROCESSING_INSTRUCTION_NODE:\n    ////case TEXT_NODE:\n    //case CDATA_SECTION_NODE:\n    //case COMMENT_NODE:\n    //\tdeep = false;\n    //\tbreak;\n    //case DOCUMENT_NODE:\n    //case DOCUMENT_TYPE_NODE:\n    //cannot be imported.\n    //case ENTITY_NODE:\n    //case NOTATION_NODE：\n    //can not hit in level3\n    //default:throw e;\n  }\n\n  if (!node2) {\n    node2 = node.cloneNode(false); //false\n  }\n\n  node2.ownerDocument = doc;\n  node2.parentNode = null;\n  if (deep) {\n    var child = node.firstChild;\n    while (child) {\n      node2.appendChild(_importNode(doc, child, deep));\n      child = child.nextSibling;\n    }\n  }\n  return node2;\n}\n//\n//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n//\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\nfunction _cloneNode(doc, node, deep) {\n  var node2 = new node.constructor();\n  for (var n in node) {\n    var v = node[n];\n    if (_typeof(v) != 'object') {\n      if (v != node2[n]) {\n        node2[n] = v;\n      }\n    }\n  }\n  if (node.childNodes) {\n    node2.childNodes = new NodeList();\n  }\n  node2.ownerDocument = doc;\n  switch (node2.nodeType) {\n    case ELEMENT_NODE:\n      var attrs = node.attributes;\n      var attrs2 = node2.attributes = new NamedNodeMap();\n      var len = attrs.length;\n      attrs2._ownerElement = node2;\n      for (var i = 0; i < len; i++) {\n        node2.setAttributeNode(_cloneNode(doc, attrs.item(i), true));\n      }\n      break;\n      ;\n    case ATTRIBUTE_NODE:\n      deep = true;\n  }\n  if (deep) {\n    var child = node.firstChild;\n    while (child) {\n      node2.appendChild(_cloneNode(doc, child, deep));\n      child = child.nextSibling;\n    }\n  }\n  return node2;\n}\nfunction __set__(object, key, value) {\n  object[key] = value;\n}\n//do dynamic\ntry {\n  if (Object.defineProperty) {\n    var getTextContent = function getTextContent(node) {\n      switch (node.nodeType) {\n        case ELEMENT_NODE:\n        case DOCUMENT_FRAGMENT_NODE:\n          var buf = [];\n          node = node.firstChild;\n          while (node) {\n            if (node.nodeType !== 7 && node.nodeType !== 8) {\n              buf.push(getTextContent(node));\n            }\n            node = node.nextSibling;\n          }\n          return buf.join('');\n        default:\n          return node.nodeValue;\n      }\n    };\n    Object.defineProperty(LiveNodeList.prototype, 'length', {\n      get: function get() {\n        _updateLiveList(this);\n        return this.$$length;\n      }\n    });\n    Object.defineProperty(Node.prototype, 'textContent', {\n      get: function get() {\n        return getTextContent(this);\n      },\n      set: function set(data) {\n        switch (this.nodeType) {\n          case ELEMENT_NODE:\n          case DOCUMENT_FRAGMENT_NODE:\n            while (this.firstChild) {\n              this.removeChild(this.firstChild);\n            }\n            if (data || String(data)) {\n              this.appendChild(this.ownerDocument.createTextNode(data));\n            }\n            break;\n          default:\n            //TODO:\n            this.data = data;\n            this.value = data;\n            this.nodeValue = data;\n        }\n      }\n    });\n    __set__ = function __set__(object, key, value) {\n      //console.log(value)\n      object['$$' + key] = value;\n    };\n  }\n} catch (e) {//ie8\n}\n\n//if(typeof require == 'function'){\nexports.DOMImplementation = DOMImplementation;\nexports.XMLSerializer = XMLSerializer;\n//}\n\n//# sourceURL=webpack://ogcparser/./node_modules/xmldom/dom.js?");

/***/ }),

/***/ "./node_modules/xmldom/sax.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/sax.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("//[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n//[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n//[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\nvar nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\nvar nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\nvar tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$');\n//var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\nvar S_TAG = 0; //tag name offerring\nvar S_ATTR = 1; //attr name offerring \nvar S_ATTR_SPACE = 2; //attr name end and space offer\nvar S_EQ = 3; //=space?\nvar S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\nvar S_ATTR_END = 5; //attr value end and no space(quot end)\nvar S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\nvar S_TAG_CLOSE = 7; //closed el<el />\n\nfunction XMLReader() {}\nXMLReader.prototype = {\n  parse: function parse(source, defaultNSMap, entityMap) {\n    var domBuilder = this.domBuilder;\n    domBuilder.startDocument();\n    _copy(defaultNSMap, defaultNSMap = {});\n    _parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n    domBuilder.endDocument();\n  }\n};\nfunction _parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n  function fixedFromCharCode(code) {\n    // String.prototype.fromCharCode does not supports\n    // > 2 bytes unicode chars directly\n    if (code > 0xffff) {\n      code -= 0x10000;\n      var surrogate1 = 0xd800 + (code >> 10),\n        surrogate2 = 0xdc00 + (code & 0x3ff);\n      return String.fromCharCode(surrogate1, surrogate2);\n    } else {\n      return String.fromCharCode(code);\n    }\n  }\n  function entityReplacer(a) {\n    var k = a.slice(1, -1);\n    if (k in entityMap) {\n      return entityMap[k];\n    } else if (k.charAt(0) === '#') {\n      return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\n    } else {\n      errorHandler.error('entity not found:' + a);\n      return a;\n    }\n  }\n  function appendText(end) {\n    //has some bugs\n    if (end > start) {\n      var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\n      locator && position(start);\n      domBuilder.characters(xt, 0, end - start);\n      start = end;\n    }\n  }\n  function position(p, m) {\n    while (p >= lineEnd && (m = linePattern.exec(source))) {\n      lineStart = m.index;\n      lineEnd = lineStart + m[0].length;\n      locator.lineNumber++;\n      //console.log('line++:',locator,startPos,endPos)\n    }\n\n    locator.columnNumber = p - lineStart + 1;\n  }\n  var lineStart = 0;\n  var lineEnd = 0;\n  var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g;\n  var locator = domBuilder.locator;\n  var parseStack = [{\n    currentNSMap: defaultNSMapCopy\n  }];\n  var closeMap = {};\n  var start = 0;\n  while (true) {\n    try {\n      var tagStart = source.indexOf('<', start);\n      if (tagStart < 0) {\n        if (!source.substr(start).match(/^\\s*$/)) {\n          var doc = domBuilder.doc;\n          var text = doc.createTextNode(source.substr(start));\n          doc.appendChild(text);\n          domBuilder.currentElement = text;\n        }\n        return;\n      }\n      if (tagStart > start) {\n        appendText(tagStart);\n      }\n      switch (source.charAt(tagStart + 1)) {\n        case '/':\n          var end = source.indexOf('>', tagStart + 3);\n          var tagName = source.substring(tagStart + 2, end);\n          var config = parseStack.pop();\n          if (end < 0) {\n            tagName = source.substring(tagStart + 2).replace(/[\\s<].*/, '');\n            //console.error('#@@@@@@'+tagName)\n            errorHandler.error(\"end tag name: \" + tagName + ' is not complete:' + config.tagName);\n            end = tagStart + 1 + tagName.length;\n          } else if (tagName.match(/\\s</)) {\n            tagName = tagName.replace(/[\\s<].*/, '');\n            errorHandler.error(\"end tag name: \" + tagName + ' maybe not complete');\n            end = tagStart + 1 + tagName.length;\n          }\n          //console.error(parseStack.length,parseStack)\n          //console.error(config);\n          var localNSMap = config.localNSMap;\n          var endMatch = config.tagName == tagName;\n          var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();\n          if (endIgnoreCaseMach) {\n            domBuilder.endElement(config.uri, config.localName, tagName);\n            if (localNSMap) {\n              for (var prefix in localNSMap) {\n                domBuilder.endPrefixMapping(prefix);\n              }\n            }\n            if (!endMatch) {\n              errorHandler.fatalError(\"end tag name: \" + tagName + ' is not match the current start tagName:' + config.tagName);\n            }\n          } else {\n            parseStack.push(config);\n          }\n          end++;\n          break;\n        // end elment\n        case '?':\n          // <?...?>\n          locator && position(tagStart);\n          end = parseInstruction(source, tagStart, domBuilder);\n          break;\n        case '!':\n          // <!doctype,<![CDATA,<!--\n          locator && position(tagStart);\n          end = parseDCC(source, tagStart, domBuilder, errorHandler);\n          break;\n        default:\n          locator && position(tagStart);\n          var el = new ElementAttributes();\n          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n          //elStartEnd\n          var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);\n          var len = el.length;\n          if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\n            el.closed = true;\n            if (!entityMap.nbsp) {\n              errorHandler.warning('unclosed xml attribute');\n            }\n          }\n          if (locator && len) {\n            var locator2 = copyLocator(locator, {});\n            //try{//attribute position fixed\n            for (var i = 0; i < len; i++) {\n              var a = el[i];\n              position(a.offset);\n              a.locator = copyLocator(locator, {});\n            }\n            //}catch(e){console.error('@@@@@'+e)}\n            domBuilder.locator = locator2;\n            if (appendElement(el, domBuilder, currentNSMap)) {\n              parseStack.push(el);\n            }\n            domBuilder.locator = locator;\n          } else {\n            if (appendElement(el, domBuilder, currentNSMap)) {\n              parseStack.push(el);\n            }\n          }\n          if (el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed) {\n            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n          } else {\n            end++;\n          }\n      }\n    } catch (e) {\n      errorHandler.error('element parse error: ' + e);\n      //errorHandler.error('element parse error: '+e);\n      end = -1;\n      //throw e;\n    }\n\n    if (end > start) {\n      start = end;\n    } else {\n      //TODO: 这里有可能sax回退，有位置错误风险\n      appendText(Math.max(tagStart, start) + 1);\n    }\n  }\n}\nfunction copyLocator(f, t) {\n  t.lineNumber = f.lineNumber;\n  t.columnNumber = f.columnNumber;\n  return t;\n}\n\n/**\r\n * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\r\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\r\n */\nfunction parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {\n  var attrName;\n  var value;\n  var p = ++start;\n  var s = S_TAG; //status\n  while (true) {\n    var c = source.charAt(p);\n    switch (c) {\n      case '=':\n        if (s === S_ATTR) {\n          //attrName\n          attrName = source.slice(start, p);\n          s = S_EQ;\n        } else if (s === S_ATTR_SPACE) {\n          s = S_EQ;\n        } else {\n          //fatalError: equal must after attrName or space after attrName\n          throw new Error('attribute equal must after attrName');\n        }\n        break;\n      case '\\'':\n      case '\"':\n        if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n        ) {\n          //equal\n          if (s === S_ATTR) {\n            errorHandler.warning('attribute value must after \"=\"');\n            attrName = source.slice(start, p);\n          }\n          start = p + 1;\n          p = source.indexOf(c, start);\n          if (p > 0) {\n            value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n            el.add(attrName, value, start - 1);\n            s = S_ATTR_END;\n          } else {\n            //fatalError: no end quot match\n            throw new Error('attribute value no end \\'' + c + '\\' match');\n          }\n        } else if (s == S_ATTR_NOQUOT_VALUE) {\n          value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n          //console.log(attrName,value,start,p)\n          el.add(attrName, value, start);\n          //console.dir(el)\n          errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n          start = p + 1;\n          s = S_ATTR_END;\n        } else {\n          //fatalError: no equal before\n          throw new Error('attribute value must after \"=\"');\n        }\n        break;\n      case '/':\n        switch (s) {\n          case S_TAG:\n            el.setTagName(source.slice(start, p));\n          case S_ATTR_END:\n          case S_TAG_SPACE:\n          case S_TAG_CLOSE:\n            s = S_TAG_CLOSE;\n            el.closed = true;\n          case S_ATTR_NOQUOT_VALUE:\n          case S_ATTR:\n          case S_ATTR_SPACE:\n            break;\n          //case S_EQ:\n          default:\n            throw new Error(\"attribute invalid close char('/')\");\n        }\n        break;\n      case '':\n        //end document\n        //throw new Error('unexpected end of input')\n        errorHandler.error('unexpected end of input');\n        if (s == S_TAG) {\n          el.setTagName(source.slice(start, p));\n        }\n        return p;\n      case '>':\n        switch (s) {\n          case S_TAG:\n            el.setTagName(source.slice(start, p));\n          case S_ATTR_END:\n          case S_TAG_SPACE:\n          case S_TAG_CLOSE:\n            break;\n          //normal\n          case S_ATTR_NOQUOT_VALUE: //Compatible state\n          case S_ATTR:\n            value = source.slice(start, p);\n            if (value.slice(-1) === '/') {\n              el.closed = true;\n              value = value.slice(0, -1);\n            }\n          case S_ATTR_SPACE:\n            if (s === S_ATTR_SPACE) {\n              value = attrName;\n            }\n            if (s == S_ATTR_NOQUOT_VALUE) {\n              errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n              el.add(attrName, value.replace(/&#?\\w+;/g, entityReplacer), start);\n            } else {\n              if (currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)) {\n                errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n              }\n              el.add(value, value, start);\n            }\n            break;\n          case S_EQ:\n            throw new Error('attribute value missed!!');\n        }\n        //\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n        return p;\n      /*xml space '\\x20' | #x9 | #xD | #xA; */\n      case \"\\x80\":\n        c = ' ';\n      default:\n        if (c <= ' ') {\n          //space\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p)); //tagName\n              s = S_TAG_SPACE;\n              break;\n            case S_ATTR:\n              attrName = source.slice(start, p);\n              s = S_ATTR_SPACE;\n              break;\n            case S_ATTR_NOQUOT_VALUE:\n              var value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n              errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n              el.add(attrName, value, start);\n            case S_ATTR_END:\n              s = S_TAG_SPACE;\n              break;\n            //case S_TAG_SPACE:\n            //case S_EQ:\n            //case S_ATTR_SPACE:\n            //\tvoid();break;\n            //case S_TAG_CLOSE:\n            //ignore warning\n          }\n        } else {\n          //not space\n          //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n          //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n          switch (s) {\n            //case S_TAG:void();break;\n            //case S_ATTR:void();break;\n            //case S_ATTR_NOQUOT_VALUE:void();break;\n            case S_ATTR_SPACE:\n              var tagName = el.tagName;\n              if (currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n                errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n              }\n              el.add(attrName, attrName, start);\n              start = p;\n              s = S_ATTR;\n              break;\n            case S_ATTR_END:\n              errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n            case S_TAG_SPACE:\n              s = S_ATTR;\n              start = p;\n              break;\n            case S_EQ:\n              s = S_ATTR_NOQUOT_VALUE;\n              start = p;\n              break;\n            case S_TAG_CLOSE:\n              throw new Error(\"elements closed character '/' and '>' must be connected to\");\n          }\n        }\n    } //end outer switch\n    //console.log('p++',p)\n    p++;\n  }\n}\n/**\r\n * @return true if has new namespace define\r\n */\nfunction appendElement(el, domBuilder, currentNSMap) {\n  var tagName = el.tagName;\n  var localNSMap = null;\n  //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n  var i = el.length;\n  while (i--) {\n    var a = el[i];\n    var qName = a.qName;\n    var value = a.value;\n    var nsp = qName.indexOf(':');\n    if (nsp > 0) {\n      var prefix = a.prefix = qName.slice(0, nsp);\n      var localName = qName.slice(nsp + 1);\n      var nsPrefix = prefix === 'xmlns' && localName;\n    } else {\n      localName = qName;\n      prefix = null;\n      nsPrefix = qName === 'xmlns' && '';\n    }\n    //can not set prefix,because prefix !== ''\n    a.localName = localName;\n    //prefix == null for no ns prefix attribute \n    if (nsPrefix !== false) {\n      //hack!!\n      if (localNSMap == null) {\n        localNSMap = {};\n        //console.log(currentNSMap,0)\n        _copy(currentNSMap, currentNSMap = {});\n        //console.log(currentNSMap,1)\n      }\n\n      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n      a.uri = 'http://www.w3.org/2000/xmlns/';\n      domBuilder.startPrefixMapping(nsPrefix, value);\n    }\n  }\n  var i = el.length;\n  while (i--) {\n    a = el[i];\n    var prefix = a.prefix;\n    if (prefix) {\n      //no prefix attribute has no namespace\n      if (prefix === 'xml') {\n        a.uri = 'http://www.w3.org/XML/1998/namespace';\n      }\n      if (prefix !== 'xmlns') {\n        a.uri = currentNSMap[prefix || ''];\n\n        //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n      }\n    }\n  }\n\n  var nsp = tagName.indexOf(':');\n  if (nsp > 0) {\n    prefix = el.prefix = tagName.slice(0, nsp);\n    localName = el.localName = tagName.slice(nsp + 1);\n  } else {\n    prefix = null; //important!!\n    localName = el.localName = tagName;\n  }\n  //no prefix element has default namespace\n  var ns = el.uri = currentNSMap[prefix || ''];\n  domBuilder.startElement(ns, localName, tagName, el);\n  //endPrefixMapping and startPrefixMapping have not any help for dom builder\n  //localNSMap = null\n  if (el.closed) {\n    domBuilder.endElement(ns, localName, tagName);\n    if (localNSMap) {\n      for (prefix in localNSMap) {\n        domBuilder.endPrefixMapping(prefix);\n      }\n    }\n  } else {\n    el.currentNSMap = currentNSMap;\n    el.localNSMap = localNSMap;\n    //parseStack.push(el);\n    return true;\n  }\n}\nfunction parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n  if (/^(?:script|textarea)$/i.test(tagName)) {\n    var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n    var text = source.substring(elStartEnd + 1, elEndStart);\n    if (/[&<]/.test(text)) {\n      if (/^script$/i.test(tagName)) {\n        //if(!/\\]\\]>/.test(text)){\n        //lexHandler.startCDATA();\n        domBuilder.characters(text, 0, text.length);\n        //lexHandler.endCDATA();\n        return elEndStart;\n        //}\n      } //}else{//text area\n      text = text.replace(/&#?\\w+;/g, entityReplacer);\n      domBuilder.characters(text, 0, text.length);\n      return elEndStart;\n      //}\n    }\n  }\n\n  return elStartEnd + 1;\n}\nfunction fixSelfClosed(source, elStartEnd, tagName, closeMap) {\n  //if(tagName in closeMap){\n  var pos = closeMap[tagName];\n  if (pos == null) {\n    //console.log(tagName)\n    pos = source.lastIndexOf('</' + tagName + '>');\n    if (pos < elStartEnd) {\n      //忘记闭合\n      pos = source.lastIndexOf('</' + tagName);\n    }\n    closeMap[tagName] = pos;\n  }\n  return pos < elStartEnd;\n  //} \n}\n\nfunction _copy(source, target) {\n  for (var n in source) {\n    target[n] = source[n];\n  }\n}\nfunction parseDCC(source, start, domBuilder, errorHandler) {\n  //sure start with '<!'\n  var next = source.charAt(start + 2);\n  switch (next) {\n    case '-':\n      if (source.charAt(start + 3) === '-') {\n        var end = source.indexOf('-->', start + 4);\n        //append comment source.substring(4,end)//<!--\n        if (end > start) {\n          domBuilder.comment(source, start + 4, end - start - 4);\n          return end + 3;\n        } else {\n          errorHandler.error(\"Unclosed comment\");\n          return -1;\n        }\n      } else {\n        //error\n        return -1;\n      }\n    default:\n      if (source.substr(start + 3, 6) == 'CDATA[') {\n        var end = source.indexOf(']]>', start + 9);\n        domBuilder.startCDATA();\n        domBuilder.characters(source, start + 9, end - start - 9);\n        domBuilder.endCDATA();\n        return end + 3;\n      }\n      //<!DOCTYPE\n      //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \n      var matchs = split(source, start);\n      var len = matchs.length;\n      if (len > 1 && /!doctype/i.test(matchs[0][0])) {\n        var name = matchs[1][0];\n        var pubid = len > 3 && /^public$/i.test(matchs[2][0]) && matchs[3][0];\n        var sysid = len > 4 && matchs[4][0];\n        var lastMatch = matchs[len - 1];\n        domBuilder.startDTD(name, pubid && pubid.replace(/^(['\"])(.*?)\\1$/, '$2'), sysid && sysid.replace(/^(['\"])(.*?)\\1$/, '$2'));\n        domBuilder.endDTD();\n        return lastMatch.index + lastMatch[0].length;\n      }\n  }\n  return -1;\n}\nfunction parseInstruction(source, start, domBuilder) {\n  var end = source.indexOf('?>', start);\n  if (end) {\n    var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n    if (match) {\n      var len = match[0].length;\n      domBuilder.processingInstruction(match[1], match[2]);\n      return end + 2;\n    } else {\n      //error\n      return -1;\n    }\n  }\n  return -1;\n}\n\n/**\r\n * @param source\r\n */\nfunction ElementAttributes(source) {}\nElementAttributes.prototype = {\n  setTagName: function setTagName(tagName) {\n    if (!tagNamePattern.test(tagName)) {\n      throw new Error('invalid tagName:' + tagName);\n    }\n    this.tagName = tagName;\n  },\n  add: function add(qName, value, offset) {\n    if (!tagNamePattern.test(qName)) {\n      throw new Error('invalid attribute:' + qName);\n    }\n    this[this.length++] = {\n      qName: qName,\n      value: value,\n      offset: offset\n    };\n  },\n  length: 0,\n  getLocalName: function getLocalName(i) {\n    return this[i].localName;\n  },\n  getLocator: function getLocator(i) {\n    return this[i].locator;\n  },\n  getQName: function getQName(i) {\n    return this[i].qName;\n  },\n  getURI: function getURI(i) {\n    return this[i].uri;\n  },\n  getValue: function getValue(i) {\n    return this[i].value;\n  }\n  //\t,getIndex:function(uri, localName)){\n  //\t\tif(localName){\n  //\t\t\t\n  //\t\t}else{\n  //\t\t\tvar qName = uri\n  //\t\t}\n  //\t},\n  //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n  //\tgetType:function(uri,localName){}\n  //\tgetType:function(i){},\n};\n\nfunction _set_proto_(thiz, parent) {\n  thiz.__proto__ = parent;\n  return thiz;\n}\nif (!(_set_proto_({}, _set_proto_.prototype) instanceof _set_proto_)) {\n  _set_proto_ = function _set_proto_(thiz, parent) {\n    function p() {}\n    ;\n    p.prototype = parent;\n    p = new p();\n    for (parent in thiz) {\n      p[parent] = thiz[parent];\n    }\n    return p;\n  };\n}\nfunction split(source, start) {\n  var match;\n  var buf = [];\n  var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n  reg.lastIndex = start;\n  reg.exec(source); //skip <\n  while (match = reg.exec(source)) {\n    buf.push(match);\n    if (match[1]) return buf;\n  }\n}\nexports.XMLReader = XMLReader;\n\n//# sourceURL=webpack://ogcparser/./node_modules/xmldom/sax.js?");

/***/ }),

/***/ "./node_modules/xpath/xpath.js":
/*!*************************************!*\
  !*** ./node_modules/xpath/xpath.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*\r\n * xpath.js\r\n *\r\n * An XPath 1.0 library for JavaScript.\r\n *\r\n * Cameron McCormack <cam (at) mcc.id.au>\r\n *\r\n * This work is licensed under the Creative Commons Attribution-ShareAlike\r\n * License. To view a copy of this license, visit\r\n *\r\n *   http://creativecommons.org/licenses/by-sa/2.0/\r\n *\r\n * or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford,\r\n * California 94305, USA.\r\n *\r\n * Revision 20: April 26, 2011\r\n *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,\r\n *   thanks to <shi_a009 (at) hotmail.com>.\r\n *\r\n * Revision 19: November 29, 2005\r\n *   Nodesets now store their nodes in a height balanced tree, increasing\r\n *   performance for the common case of selecting nodes in document order,\r\n *   thanks to S閎astien Cramatte <contact (at) zeninteractif.com>.\r\n *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.\r\n *\r\n * Revision 18: October 27, 2005\r\n *   DOM 3 XPath support.  Caveats:\r\n *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,\r\n *       but in XPathExpression.evaluate.\r\n *     - XPathResult.invalidIteratorState is not implemented.\r\n *\r\n * Revision 17: October 25, 2005\r\n *   Some core XPath function fixes and a patch to avoid crashing certain\r\n *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to\r\n *   S閎astien Cramatte <contact (at) zeninteractif.com>.\r\n *\r\n * Revision 16: September 22, 2005\r\n *   Workarounds for some IE 5.5 deficiencies.\r\n *   Fixed problem with prefix node tests on attribute nodes.\r\n *\r\n * Revision 15: May 21, 2005\r\n *   Fixed problem with QName node tests on elements with an xmlns=\"...\".\r\n *\r\n * Revision 14: May 19, 2005\r\n *   Fixed QName node tests on attribute node regression.\r\n *\r\n * Revision 13: May 3, 2005\r\n *   Node tests are case insensitive now if working in an HTML DOM.\r\n *\r\n * Revision 12: April 26, 2005\r\n *   Updated licence.  Slight code changes to enable use of Dean\r\n *   Edwards' script compression, http://dean.edwards.name/packer/ .\r\n *\r\n * Revision 11: April 23, 2005\r\n *   Fixed bug with 'and' and 'or' operators, fix thanks to\r\n *   Sandy McArthur <sandy (at) mcarthur.org>.\r\n *\r\n * Revision 10: April 15, 2005\r\n *   Added support for a virtual root node, supposedly helpful for\r\n *   implementing XForms.  Fixed problem with QName node tests and\r\n *   the parent axis.\r\n *\r\n * Revision 9: March 17, 2005\r\n *   Namespace resolver tweaked so using the document node as the context\r\n *   for namespace lookups is equivalent to using the document element.\r\n *\r\n * Revision 8: February 13, 2005\r\n *   Handle implicit declaration of 'xmlns' namespace prefix.\r\n *   Fixed bug when comparing nodesets.\r\n *   Instance data can now be associated with a FunctionResolver, and\r\n *     workaround for MSXML not supporting 'localName' and 'getElementById',\r\n *     thanks to Grant Gongaware.\r\n *   Fix a few problems when the context node is the root node.\r\n *\r\n * Revision 7: February 11, 2005\r\n *   Default namespace resolver fix from Grant Gongaware\r\n *   <grant (at) gongaware.com>.\r\n *\r\n * Revision 6: February 10, 2005\r\n *   Fixed bug in 'number' function.\r\n *\r\n * Revision 5: February 9, 2005\r\n *   Fixed bug where text nodes not getting converted to string values.\r\n *\r\n * Revision 4: January 21, 2005\r\n *   Bug in 'name' function, fix thanks to Bill Edney.\r\n *   Fixed incorrect processing of namespace nodes.\r\n *   Fixed NamespaceResolver to resolve 'xml' namespace.\r\n *   Implemented union '|' operator.\r\n *\r\n * Revision 3: January 14, 2005\r\n *   Fixed bug with nodeset comparisons, bug lexing < and >.\r\n *\r\n * Revision 2: October 26, 2004\r\n *   QName node test namespace handling fixed.  Few other bug fixes.\r\n *\r\n * Revision 1: August 13, 2004\r\n *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.\r\n *   Added minimal licence.\r\n *\r\n * Initial version: June 14, 2004\r\n */\n\n// non-node wrapper\nvar xpath =  false ? 0 : exports;\n(function (exports) {\n  \"use strict\";\n\n  // XPathParser ///////////////////////////////////////////////////////////////\n  XPathParser.prototype = new Object();\n  XPathParser.prototype.constructor = XPathParser;\n  XPathParser.superclass = Object.prototype;\n  function XPathParser() {\n    this.init();\n  }\n  XPathParser.prototype.init = function () {\n    this.reduceActions = [];\n    this.reduceActions[3] = function (rhs) {\n      return new OrOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[5] = function (rhs) {\n      return new AndOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[7] = function (rhs) {\n      return new EqualsOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[8] = function (rhs) {\n      return new NotEqualOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[10] = function (rhs) {\n      return new LessThanOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[11] = function (rhs) {\n      return new GreaterThanOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[12] = function (rhs) {\n      return new LessThanOrEqualOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[13] = function (rhs) {\n      return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[15] = function (rhs) {\n      return new PlusOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[16] = function (rhs) {\n      return new MinusOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[18] = function (rhs) {\n      return new MultiplyOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[19] = function (rhs) {\n      return new DivOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[20] = function (rhs) {\n      return new ModOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[22] = function (rhs) {\n      return new UnaryMinusOperation(rhs[1]);\n    };\n    this.reduceActions[24] = function (rhs) {\n      return new BarOperation(rhs[0], rhs[2]);\n    };\n    this.reduceActions[25] = function (rhs) {\n      return new PathExpr(undefined, undefined, rhs[0]);\n    };\n    this.reduceActions[27] = function (rhs) {\n      rhs[0].locationPath = rhs[2];\n      return rhs[0];\n    };\n    this.reduceActions[28] = function (rhs) {\n      rhs[0].locationPath = rhs[2];\n      rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));\n      return rhs[0];\n    };\n    this.reduceActions[29] = function (rhs) {\n      return new PathExpr(rhs[0], [], undefined);\n    };\n    this.reduceActions[30] = function (rhs) {\n      if (Utilities.instance_of(rhs[0], PathExpr)) {\n        if (rhs[0].filterPredicates == undefined) {\n          rhs[0].filterPredicates = [];\n        }\n        rhs[0].filterPredicates.push(rhs[1]);\n        return rhs[0];\n      } else {\n        return new PathExpr(rhs[0], [rhs[1]], undefined);\n      }\n    };\n    this.reduceActions[32] = function (rhs) {\n      return rhs[1];\n    };\n    this.reduceActions[33] = function (rhs) {\n      return new XString(rhs[0]);\n    };\n    this.reduceActions[34] = function (rhs) {\n      return new XNumber(rhs[0]);\n    };\n    this.reduceActions[36] = function (rhs) {\n      return new FunctionCall(rhs[0], []);\n    };\n    this.reduceActions[37] = function (rhs) {\n      return new FunctionCall(rhs[0], rhs[2]);\n    };\n    this.reduceActions[38] = function (rhs) {\n      return [rhs[0]];\n    };\n    this.reduceActions[39] = function (rhs) {\n      rhs[2].unshift(rhs[0]);\n      return rhs[2];\n    };\n    this.reduceActions[43] = function (rhs) {\n      return new LocationPath(true, []);\n    };\n    this.reduceActions[44] = function (rhs) {\n      rhs[1].absolute = true;\n      return rhs[1];\n    };\n    this.reduceActions[46] = function (rhs) {\n      return new LocationPath(false, [rhs[0]]);\n    };\n    this.reduceActions[47] = function (rhs) {\n      rhs[0].steps.push(rhs[2]);\n      return rhs[0];\n    };\n    this.reduceActions[49] = function (rhs) {\n      return new Step(rhs[0], rhs[1], []);\n    };\n    this.reduceActions[50] = function (rhs) {\n      return new Step(Step.CHILD, rhs[0], []);\n    };\n    this.reduceActions[51] = function (rhs) {\n      return new Step(rhs[0], rhs[1], rhs[2]);\n    };\n    this.reduceActions[52] = function (rhs) {\n      return new Step(Step.CHILD, rhs[0], rhs[1]);\n    };\n    this.reduceActions[54] = function (rhs) {\n      return [rhs[0]];\n    };\n    this.reduceActions[55] = function (rhs) {\n      rhs[1].unshift(rhs[0]);\n      return rhs[1];\n    };\n    this.reduceActions[56] = function (rhs) {\n      if (rhs[0] == \"ancestor\") {\n        return Step.ANCESTOR;\n      } else if (rhs[0] == \"ancestor-or-self\") {\n        return Step.ANCESTORORSELF;\n      } else if (rhs[0] == \"attribute\") {\n        return Step.ATTRIBUTE;\n      } else if (rhs[0] == \"child\") {\n        return Step.CHILD;\n      } else if (rhs[0] == \"descendant\") {\n        return Step.DESCENDANT;\n      } else if (rhs[0] == \"descendant-or-self\") {\n        return Step.DESCENDANTORSELF;\n      } else if (rhs[0] == \"following\") {\n        return Step.FOLLOWING;\n      } else if (rhs[0] == \"following-sibling\") {\n        return Step.FOLLOWINGSIBLING;\n      } else if (rhs[0] == \"namespace\") {\n        return Step.NAMESPACE;\n      } else if (rhs[0] == \"parent\") {\n        return Step.PARENT;\n      } else if (rhs[0] == \"preceding\") {\n        return Step.PRECEDING;\n      } else if (rhs[0] == \"preceding-sibling\") {\n        return Step.PRECEDINGSIBLING;\n      } else if (rhs[0] == \"self\") {\n        return Step.SELF;\n      }\n      return -1;\n    };\n    this.reduceActions[57] = function (rhs) {\n      return Step.ATTRIBUTE;\n    };\n    this.reduceActions[59] = function (rhs) {\n      if (rhs[0] == \"comment\") {\n        return new NodeTest(NodeTest.COMMENT, undefined);\n      } else if (rhs[0] == \"text\") {\n        return new NodeTest(NodeTest.TEXT, undefined);\n      } else if (rhs[0] == \"processing-instruction\") {\n        return new NodeTest(NodeTest.PI, undefined);\n      } else if (rhs[0] == \"node\") {\n        return new NodeTest(NodeTest.NODE, undefined);\n      }\n      return new NodeTest(-1, undefined);\n    };\n    this.reduceActions[60] = function (rhs) {\n      return new NodeTest(NodeTest.PI, rhs[2]);\n    };\n    this.reduceActions[61] = function (rhs) {\n      return rhs[1];\n    };\n    this.reduceActions[63] = function (rhs) {\n      rhs[1].absolute = true;\n      rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));\n      return rhs[1];\n    };\n    this.reduceActions[64] = function (rhs) {\n      rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));\n      rhs[0].steps.push(rhs[2]);\n      return rhs[0];\n    };\n    this.reduceActions[65] = function (rhs) {\n      return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);\n    };\n    this.reduceActions[66] = function (rhs) {\n      return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);\n    };\n    this.reduceActions[67] = function (rhs) {\n      return new VariableReference(rhs[1]);\n    };\n    this.reduceActions[68] = function (rhs) {\n      return new NodeTest(NodeTest.NAMETESTANY, undefined);\n    };\n    this.reduceActions[69] = function (rhs) {\n      var prefix = rhs[0].substring(0, rhs[0].indexOf(\":\"));\n      return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);\n    };\n    this.reduceActions[70] = function (rhs) {\n      return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);\n    };\n  };\n  XPathParser.actionTable = [\" s s        sssssssss    s ss  s  ss\", \"                 s                  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"                rrrrr               \", \" s s        sssssssss    s ss  s  ss\", \"rs  rrrrrrrr s  sssssrrrrrr  rrs rs \", \" s s        sssssssss    s ss  s  ss\", \"                            s       \", \"                            s       \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"  s                                 \", \"                            s       \", \" s           s  sssss          s  s \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"a                                   \", \"r       s                    rr  r  \", \"r      sr                    rr  r  \", \"r   s  rr            s       rr  r  \", \"r   rssrr            rss     rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrrsss         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrrs  rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r  srrrrrrrr         rrrrrrs rr sr  \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"                sssss               \", \"r  rrrrrrrrr         rrrrrrr rr sr  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             s      \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"              s                     \", \"                             s      \", \"                rrrrr               \", \" s s        sssssssss    s sss s  ss\", \"r  srrrrrrrr         rrrrrrs rr  r  \", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss      ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s           s  sssss          s  s \", \" s           s  sssss          s  s \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \" s           s  sssss          s  s \", \" s           s  sssss          s  s \", \"r  rrrrrrrrr         rrrrrrr rr sr  \", \"r  rrrrrrrrr         rrrrrrr rr sr  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             s      \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             rr     \", \"                             s      \", \"                             rs     \", \"r      sr                    rr  r  \", \"r   s  rr            s       rr  r  \", \"r   rssrr            rss     rr  r  \", \"r   rssrr            rss     rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrrsss         rrrrr   rr  r  \", \"r   rrrrrsss         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"                                 r  \", \"                                 s  \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \" s s        sssssssss    s ss  s  ss\", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             r      \"];\n  XPathParser.actionTableNumber = [\" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"                 J                  \", \"a  aaaaaaaaa         aaaaaaa aa  a  \", \"                YYYYY               \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\\\" \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"                            N       \", \"                            O       \", \"e  eeeeeeeee         eeeeeee ee ee  \", \"f  fffffffff         fffffff ff ff  \", \"d  ddddddddd         ddddddd dd dd  \", \"B  BBBBBBBBB         BBBBBBB BB BB  \", \"A  AAAAAAAAA         AAAAAAA AA AA  \", \"  P                                 \", \"                            Q       \", \" 1           .  +*)('          #  \\\" \", \"b  bbbbbbbbb         bbbbbbb bb  b  \", \"                                    \", \"!       S                    !!  !  \", \"\\\"      T\\\"                    \\\"\\\"  \\\"  \", \"$   V  $$            U       $$  $  \", \"&   &ZY&&            &XW     &&  &  \", \")   )))))            )))\\\\[   ))  )  \", \".   ....._^]         .....   ..  .  \", \"1   11111111         11111   11  1  \", \"5   55555555         55555`  55  5  \", \"7   77777777         777777  77  7  \", \"9   99999999         999999  99  9  \", \":  c::::::::         ::::::b :: a:  \", \"I  fIIIIIIII         IIIIIIe II  I  \", \"=  =========         ======= == ==  \", \"?  ?????????         ??????? ?? ??  \", \"C  CCCCCCCCC         CCCCCCC CC CC  \", \"J   JJJJJJJJ         JJJJJJ  JJ  J  \", \"M   MMMMMMMM         MMMMMM  MM  M  \", \"N  NNNNNNNNN         NNNNNNN NN  N  \", \"P  PPPPPPPPP         PPPPPPP PP  P  \", \"                +*)('               \", \"R  RRRRRRRRR         RRRRRRR RR aR  \", \"U  UUUUUUUUU         UUUUUUU UU  U  \", \"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  \", \"c  ccccccccc         ccccccc cc cc  \", \"                             j      \", \"L  fLLLLLLLL         LLLLLLe LL  L  \", \"6   66666666         66666   66  6  \", \"              k                     \", \"                             l      \", \"                XXXXX               \", \" 1 0        /.-,+*)('    & %$m #  \\\"!\", \"_  f________         ______e __  _  \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('      %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1           .  +*)('          #  \\\" \", \" 1           .  +*)('          #  \\\" \", \">  >>>>>>>>>         >>>>>>> >> >>  \", \" 1           .  +*)('          #  \\\" \", \" 1           .  +*)('          #  \\\" \", \"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  \", \"V  VVVVVVVVV         VVVVVVV VV aV  \", \"T  TTTTTTTTT         TTTTTTT TT  T  \", \"@  @@@@@@@@@         @@@@@@@ @@ @@  \", \"                             \\x87      \", \"[  [[[[[[[[[         [[[[[[[ [[ [[  \", \"D  DDDDDDDDD         DDDDDDD DD DD  \", \"                             HH     \", \"                             \\x88      \", \"                             F\\x89     \", \"#      T#                    ##  #  \", \"%   V  %%            U       %%  %  \", \"'   'ZY''            'XW     ''  '  \", \"(   (ZY((            (XW     ((  (  \", \"+   +++++            +++\\\\[   ++  +  \", \"*   *****            ***\\\\[   **  *  \", \"-   -----            ---\\\\[   --  -  \", \",   ,,,,,            ,,,\\\\[   ,,  ,  \", \"0   00000_^]         00000   00  0  \", \"/   /////_^]         /////   //  /  \", \"2   22222222         22222   22  2  \", \"3   33333333         33333   33  3  \", \"4   44444444         44444   44  4  \", \"8   88888888         888888  88  8  \", \"                                 ^  \", \"                                 \\x8a  \", \";  f;;;;;;;;         ;;;;;;e ;;  ;  \", \"<  f<<<<<<<<         <<<<<<e <<  <  \", \"O  OOOOOOOOO         OOOOOOO OO  O  \", \"`  `````````         ``````` ``  `  \", \"S  SSSSSSSSS         SSSSSSS SS  S  \", \"W  WWWWWWWWW         WWWWWWW WW  W  \", \"\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\ \\\\\\\\  \", \"E  EEEEEEEEE         EEEEEEE EE EE  \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"]  ]]]]]]]]]         ]]]]]]] ]] ]]  \", \"                             G      \"];\n  XPathParser.gotoTable = [\"3456789:;<=>?@ AB  CDEFGH IJ \", \"                             \", \"                             \", \"                             \", \"L456789:;<=>?@ AB  CDEFGH IJ \", \"            M        EFGH IJ \", \"       N;<=>?@ AB  CDEFGH IJ \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"            S        EFGH IJ \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"              e              \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                        h  J \", \"              i          j   \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"o456789:;<=>?@ ABpqCDEFGH IJ \", \"                             \", \"  r6789:;<=>?@ AB  CDEFGH IJ \", \"   s789:;<=>?@ AB  CDEFGH IJ \", \"    t89:;<=>?@ AB  CDEFGH IJ \", \"    u89:;<=>?@ AB  CDEFGH IJ \", \"     v9:;<=>?@ AB  CDEFGH IJ \", \"     w9:;<=>?@ AB  CDEFGH IJ \", \"     x9:;<=>?@ AB  CDEFGH IJ \", \"     y9:;<=>?@ AB  CDEFGH IJ \", \"      z:;<=>?@ AB  CDEFGH IJ \", \"      {:;<=>?@ AB  CDEFGH IJ \", \"       |;<=>?@ AB  CDEFGH IJ \", \"       };<=>?@ AB  CDEFGH IJ \", \"       ~;<=>?@ AB  CDEFGH IJ \", \"         \\x7f=>?@ AB  CDEFGH IJ \", \"\\x80456789:;<=>?@ AB  CDEFGH IJ\\x81\", \"            \\x82        EFGH IJ \", \"            \\x83        EFGH IJ \", \"                             \", \"                     \\x84 GH IJ \", \"                     \\x85 GH IJ \", \"              i          \\x86   \", \"              i          \\x87   \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"o456789:;<=>?@ AB\\x8cqCDEFGH IJ \", \"                             \", \"                             \"];\n  XPathParser.productions = [[1, 1, 2], [2, 1, 3], [3, 1, 4], [3, 3, 3, -9, 4], [4, 1, 5], [4, 3, 4, -8, 5], [5, 1, 6], [5, 3, 5, -22, 6], [5, 3, 5, -5, 6], [6, 1, 7], [6, 3, 6, -23, 7], [6, 3, 6, -24, 7], [6, 3, 6, -6, 7], [6, 3, 6, -7, 7], [7, 1, 8], [7, 3, 7, -25, 8], [7, 3, 7, -26, 8], [8, 1, 9], [8, 3, 8, -12, 9], [8, 3, 8, -11, 9], [8, 3, 8, -10, 9], [9, 1, 10], [9, 2, -26, 9], [10, 1, 11], [10, 3, 10, -27, 11], [11, 1, 12], [11, 1, 13], [11, 3, 13, -28, 14], [11, 3, 13, -4, 14], [13, 1, 15], [13, 2, 13, 16], [15, 1, 17], [15, 3, -29, 2, -30], [15, 1, -15], [15, 1, -16], [15, 1, 18], [18, 3, -13, -29, -30], [18, 4, -13, -29, 19, -30], [19, 1, 20], [19, 3, 20, -31, 19], [20, 1, 2], [12, 1, 14], [12, 1, 21], [21, 1, -28], [21, 2, -28, 14], [21, 1, 22], [14, 1, 23], [14, 3, 14, -28, 23], [14, 1, 24], [23, 2, 25, 26], [23, 1, 26], [23, 3, 25, 26, 27], [23, 2, 26, 27], [23, 1, 28], [27, 1, 16], [27, 2, 16, 27], [25, 2, -14, -3], [25, 1, -32], [26, 1, 29], [26, 3, -20, -29, -30], [26, 4, -21, -29, -15, -30], [16, 3, -33, 30, -34], [30, 1, 2], [22, 2, -4, 14], [24, 3, 14, -4, 23], [28, 1, -35], [28, 1, -2], [17, 2, -36, -18], [29, 1, -17], [29, 1, -19], [29, 1, -18]];\n  XPathParser.DOUBLEDOT = 2;\n  XPathParser.DOUBLECOLON = 3;\n  XPathParser.DOUBLESLASH = 4;\n  XPathParser.NOTEQUAL = 5;\n  XPathParser.LESSTHANOREQUAL = 6;\n  XPathParser.GREATERTHANOREQUAL = 7;\n  XPathParser.AND = 8;\n  XPathParser.OR = 9;\n  XPathParser.MOD = 10;\n  XPathParser.DIV = 11;\n  XPathParser.MULTIPLYOPERATOR = 12;\n  XPathParser.FUNCTIONNAME = 13;\n  XPathParser.AXISNAME = 14;\n  XPathParser.LITERAL = 15;\n  XPathParser.NUMBER = 16;\n  XPathParser.ASTERISKNAMETEST = 17;\n  XPathParser.QNAME = 18;\n  XPathParser.NCNAMECOLONASTERISK = 19;\n  XPathParser.NODETYPE = 20;\n  XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;\n  XPathParser.EQUALS = 22;\n  XPathParser.LESSTHAN = 23;\n  XPathParser.GREATERTHAN = 24;\n  XPathParser.PLUS = 25;\n  XPathParser.MINUS = 26;\n  XPathParser.BAR = 27;\n  XPathParser.SLASH = 28;\n  XPathParser.LEFTPARENTHESIS = 29;\n  XPathParser.RIGHTPARENTHESIS = 30;\n  XPathParser.COMMA = 31;\n  XPathParser.AT = 32;\n  XPathParser.LEFTBRACKET = 33;\n  XPathParser.RIGHTBRACKET = 34;\n  XPathParser.DOT = 35;\n  XPathParser.DOLLAR = 36;\n  XPathParser.prototype.tokenize = function (s1) {\n    var types = [];\n    var values = [];\n    var s = s1 + '\\0';\n    var pos = 0;\n    var c = s.charAt(pos++);\n    while (1) {\n      while (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n        c = s.charAt(pos++);\n      }\n      if (c == '\\0' || pos >= s.length) {\n        break;\n      }\n      if (c == '(') {\n        types.push(XPathParser.LEFTPARENTHESIS);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == ')') {\n        types.push(XPathParser.RIGHTPARENTHESIS);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '[') {\n        types.push(XPathParser.LEFTBRACKET);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == ']') {\n        types.push(XPathParser.RIGHTBRACKET);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '@') {\n        types.push(XPathParser.AT);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == ',') {\n        types.push(XPathParser.COMMA);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '|') {\n        types.push(XPathParser.BAR);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '+') {\n        types.push(XPathParser.PLUS);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '-') {\n        types.push(XPathParser.MINUS);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '=') {\n        types.push(XPathParser.EQUALS);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '$') {\n        types.push(XPathParser.DOLLAR);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '.') {\n        c = s.charAt(pos++);\n        if (c == '.') {\n          types.push(XPathParser.DOUBLEDOT);\n          values.push(\"..\");\n          c = s.charAt(pos++);\n          continue;\n        }\n        if (c >= '0' && c <= '9') {\n          var number = \".\" + c;\n          c = s.charAt(pos++);\n          while (c >= '0' && c <= '9') {\n            number += c;\n            c = s.charAt(pos++);\n          }\n          types.push(XPathParser.NUMBER);\n          values.push(number);\n          continue;\n        }\n        types.push(XPathParser.DOT);\n        values.push('.');\n        continue;\n      }\n      if (c == '\\'' || c == '\"') {\n        var delimiter = c;\n        var literal = \"\";\n        while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {\n          literal += c;\n          pos += 1;\n        }\n        if (c !== delimiter) {\n          throw XPathException.fromMessage(\"Unterminated string literal: \" + delimiter + literal);\n        }\n        pos += 1;\n        types.push(XPathParser.LITERAL);\n        values.push(literal);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c >= '0' && c <= '9') {\n        var number = c;\n        c = s.charAt(pos++);\n        while (c >= '0' && c <= '9') {\n          number += c;\n          c = s.charAt(pos++);\n        }\n        if (c == '.') {\n          if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {\n            number += c;\n            number += s.charAt(pos++);\n            c = s.charAt(pos++);\n            while (c >= '0' && c <= '9') {\n              number += c;\n              c = s.charAt(pos++);\n            }\n          }\n        }\n        types.push(XPathParser.NUMBER);\n        values.push(number);\n        continue;\n      }\n      if (c == '*') {\n        if (types.length > 0) {\n          var last = types[types.length - 1];\n          if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {\n            types.push(XPathParser.MULTIPLYOPERATOR);\n            values.push(c);\n            c = s.charAt(pos++);\n            continue;\n          }\n        }\n        types.push(XPathParser.ASTERISKNAMETEST);\n        values.push(c);\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == ':') {\n        if (s.charAt(pos) == ':') {\n          types.push(XPathParser.DOUBLECOLON);\n          values.push(\"::\");\n          pos++;\n          c = s.charAt(pos++);\n          continue;\n        }\n      }\n      if (c == '/') {\n        c = s.charAt(pos++);\n        if (c == '/') {\n          types.push(XPathParser.DOUBLESLASH);\n          values.push(\"//\");\n          c = s.charAt(pos++);\n          continue;\n        }\n        types.push(XPathParser.SLASH);\n        values.push('/');\n        continue;\n      }\n      if (c == '!') {\n        if (s.charAt(pos) == '=') {\n          types.push(XPathParser.NOTEQUAL);\n          values.push(\"!=\");\n          pos++;\n          c = s.charAt(pos++);\n          continue;\n        }\n      }\n      if (c == '<') {\n        if (s.charAt(pos) == '=') {\n          types.push(XPathParser.LESSTHANOREQUAL);\n          values.push(\"<=\");\n          pos++;\n          c = s.charAt(pos++);\n          continue;\n        }\n        types.push(XPathParser.LESSTHAN);\n        values.push('<');\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '>') {\n        if (s.charAt(pos) == '=') {\n          types.push(XPathParser.GREATERTHANOREQUAL);\n          values.push(\">=\");\n          pos++;\n          c = s.charAt(pos++);\n          continue;\n        }\n        types.push(XPathParser.GREATERTHAN);\n        values.push('>');\n        c = s.charAt(pos++);\n        continue;\n      }\n      if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {\n        var name = c;\n        c = s.charAt(pos++);\n        while (Utilities.isNCNameChar(c.charCodeAt(0))) {\n          name += c;\n          c = s.charAt(pos++);\n        }\n        if (types.length > 0) {\n          var last = types[types.length - 1];\n          if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {\n            if (name == \"and\") {\n              types.push(XPathParser.AND);\n              values.push(name);\n              continue;\n            }\n            if (name == \"or\") {\n              types.push(XPathParser.OR);\n              values.push(name);\n              continue;\n            }\n            if (name == \"mod\") {\n              types.push(XPathParser.MOD);\n              values.push(name);\n              continue;\n            }\n            if (name == \"div\") {\n              types.push(XPathParser.DIV);\n              values.push(name);\n              continue;\n            }\n          }\n        }\n        if (c == ':') {\n          if (s.charAt(pos) == '*') {\n            types.push(XPathParser.NCNAMECOLONASTERISK);\n            values.push(name + \":*\");\n            pos++;\n            c = s.charAt(pos++);\n            continue;\n          }\n          if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {\n            name += ':';\n            c = s.charAt(pos++);\n            while (Utilities.isNCNameChar(c.charCodeAt(0))) {\n              name += c;\n              c = s.charAt(pos++);\n            }\n            if (c == '(') {\n              types.push(XPathParser.FUNCTIONNAME);\n              values.push(name);\n              continue;\n            }\n            types.push(XPathParser.QNAME);\n            values.push(name);\n            continue;\n          }\n          if (s.charAt(pos) == ':') {\n            types.push(XPathParser.AXISNAME);\n            values.push(name);\n            continue;\n          }\n        }\n        if (c == '(') {\n          if (name == \"comment\" || name == \"text\" || name == \"node\") {\n            types.push(XPathParser.NODETYPE);\n            values.push(name);\n            continue;\n          }\n          if (name == \"processing-instruction\") {\n            if (s.charAt(pos) == ')') {\n              types.push(XPathParser.NODETYPE);\n            } else {\n              types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);\n            }\n            values.push(name);\n            continue;\n          }\n          types.push(XPathParser.FUNCTIONNAME);\n          values.push(name);\n          continue;\n        }\n        types.push(XPathParser.QNAME);\n        values.push(name);\n        continue;\n      }\n      throw new Error(\"Unexpected character \" + c);\n    }\n    types.push(1);\n    values.push(\"[EOF]\");\n    return [types, values];\n  };\n  XPathParser.SHIFT = 's';\n  XPathParser.REDUCE = 'r';\n  XPathParser.ACCEPT = 'a';\n  XPathParser.prototype.parse = function (s) {\n    var types;\n    var values;\n    var res = this.tokenize(s);\n    if (res == undefined) {\n      return undefined;\n    }\n    types = res[0];\n    values = res[1];\n    var tokenPos = 0;\n    var state = [];\n    var tokenType = [];\n    var tokenValue = [];\n    var s;\n    var a;\n    var t;\n    state.push(0);\n    tokenType.push(1);\n    tokenValue.push(\"_S\");\n    a = types[tokenPos];\n    t = values[tokenPos++];\n    while (1) {\n      s = state[state.length - 1];\n      switch (XPathParser.actionTable[s].charAt(a - 1)) {\n        case XPathParser.SHIFT:\n          tokenType.push(-a);\n          tokenValue.push(t);\n          state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);\n          a = types[tokenPos];\n          t = values[tokenPos++];\n          break;\n        case XPathParser.REDUCE:\n          var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];\n          var rhs = [];\n          for (var i = 0; i < num; i++) {\n            tokenType.pop();\n            rhs.unshift(tokenValue.pop());\n            state.pop();\n          }\n          var s_ = state[state.length - 1];\n          tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);\n          if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {\n            tokenValue.push(rhs[0]);\n          } else {\n            tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));\n          }\n          state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);\n          break;\n        case XPathParser.ACCEPT:\n          return new XPath(tokenValue.pop());\n        default:\n          throw new Error(\"XPath parse error\");\n      }\n    }\n  };\n\n  // XPath /////////////////////////////////////////////////////////////////////\n\n  XPath.prototype = new Object();\n  XPath.prototype.constructor = XPath;\n  XPath.superclass = Object.prototype;\n  function XPath(e) {\n    this.expression = e;\n  }\n  XPath.prototype.toString = function () {\n    return this.expression.toString();\n  };\n  XPath.prototype.evaluate = function (c) {\n    c.contextNode = c.expressionContextNode;\n    c.contextSize = 1;\n    c.contextPosition = 1;\n    c.caseInsensitive = false;\n    if (c.contextNode != null) {\n      var doc = c.contextNode;\n      if (doc.nodeType != 9 /*Node.DOCUMENT_NODE*/) {\n        doc = doc.ownerDocument;\n      }\n      try {\n        c.caseInsensitive = doc.implementation.hasFeature(\"HTML\", \"2.0\");\n      } catch (e) {\n        c.caseInsensitive = true;\n      }\n    }\n    return this.expression.evaluate(c);\n  };\n  XPath.XML_NAMESPACE_URI = \"http://www.w3.org/XML/1998/namespace\";\n  XPath.XMLNS_NAMESPACE_URI = \"http://www.w3.org/2000/xmlns/\";\n\n  // Expression ////////////////////////////////////////////////////////////////\n\n  Expression.prototype = new Object();\n  Expression.prototype.constructor = Expression;\n  Expression.superclass = Object.prototype;\n  function Expression() {}\n  Expression.prototype.init = function () {};\n  Expression.prototype.toString = function () {\n    return \"<Expression>\";\n  };\n  Expression.prototype.evaluate = function (c) {\n    throw new Error(\"Could not evaluate expression.\");\n  };\n\n  // UnaryOperation ////////////////////////////////////////////////////////////\n\n  UnaryOperation.prototype = new Expression();\n  UnaryOperation.prototype.constructor = UnaryOperation;\n  UnaryOperation.superclass = Expression.prototype;\n  function UnaryOperation(rhs) {\n    if (arguments.length > 0) {\n      this.init(rhs);\n    }\n  }\n  UnaryOperation.prototype.init = function (rhs) {\n    this.rhs = rhs;\n  };\n\n  // UnaryMinusOperation ///////////////////////////////////////////////////////\n\n  UnaryMinusOperation.prototype = new UnaryOperation();\n  UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;\n  UnaryMinusOperation.superclass = UnaryOperation.prototype;\n  function UnaryMinusOperation(rhs) {\n    if (arguments.length > 0) {\n      this.init(rhs);\n    }\n  }\n  UnaryMinusOperation.prototype.init = function (rhs) {\n    UnaryMinusOperation.superclass.init.call(this, rhs);\n  };\n  UnaryMinusOperation.prototype.evaluate = function (c) {\n    return this.rhs.evaluate(c).number().negate();\n  };\n  UnaryMinusOperation.prototype.toString = function () {\n    return \"-\" + this.rhs.toString();\n  };\n\n  // BinaryOperation ///////////////////////////////////////////////////////////\n\n  BinaryOperation.prototype = new Expression();\n  BinaryOperation.prototype.constructor = BinaryOperation;\n  BinaryOperation.superclass = Expression.prototype;\n  function BinaryOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  BinaryOperation.prototype.init = function (lhs, rhs) {\n    this.lhs = lhs;\n    this.rhs = rhs;\n  };\n\n  // OrOperation ///////////////////////////////////////////////////////////////\n\n  OrOperation.prototype = new BinaryOperation();\n  OrOperation.prototype.constructor = OrOperation;\n  OrOperation.superclass = BinaryOperation.prototype;\n  function OrOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  OrOperation.prototype.init = function (lhs, rhs) {\n    OrOperation.superclass.init.call(this, lhs, rhs);\n  };\n  OrOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" or \" + this.rhs.toString() + \")\";\n  };\n  OrOperation.prototype.evaluate = function (c) {\n    var b = this.lhs.evaluate(c).bool();\n    if (b.booleanValue()) {\n      return b;\n    }\n    return this.rhs.evaluate(c).bool();\n  };\n\n  // AndOperation //////////////////////////////////////////////////////////////\n\n  AndOperation.prototype = new BinaryOperation();\n  AndOperation.prototype.constructor = AndOperation;\n  AndOperation.superclass = BinaryOperation.prototype;\n  function AndOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  AndOperation.prototype.init = function (lhs, rhs) {\n    AndOperation.superclass.init.call(this, lhs, rhs);\n  };\n  AndOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" and \" + this.rhs.toString() + \")\";\n  };\n  AndOperation.prototype.evaluate = function (c) {\n    var b = this.lhs.evaluate(c).bool();\n    if (!b.booleanValue()) {\n      return b;\n    }\n    return this.rhs.evaluate(c).bool();\n  };\n\n  // EqualsOperation ///////////////////////////////////////////////////////////\n\n  EqualsOperation.prototype = new BinaryOperation();\n  EqualsOperation.prototype.constructor = EqualsOperation;\n  EqualsOperation.superclass = BinaryOperation.prototype;\n  function EqualsOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  EqualsOperation.prototype.init = function (lhs, rhs) {\n    EqualsOperation.superclass.init.call(this, lhs, rhs);\n  };\n  EqualsOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" = \" + this.rhs.toString() + \")\";\n  };\n  EqualsOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));\n  };\n\n  // NotEqualOperation /////////////////////////////////////////////////////////\n\n  NotEqualOperation.prototype = new BinaryOperation();\n  NotEqualOperation.prototype.constructor = NotEqualOperation;\n  NotEqualOperation.superclass = BinaryOperation.prototype;\n  function NotEqualOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  NotEqualOperation.prototype.init = function (lhs, rhs) {\n    NotEqualOperation.superclass.init.call(this, lhs, rhs);\n  };\n  NotEqualOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" != \" + this.rhs.toString() + \")\";\n  };\n  NotEqualOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));\n  };\n\n  // LessThanOperation /////////////////////////////////////////////////////////\n\n  LessThanOperation.prototype = new BinaryOperation();\n  LessThanOperation.prototype.constructor = LessThanOperation;\n  LessThanOperation.superclass = BinaryOperation.prototype;\n  function LessThanOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  LessThanOperation.prototype.init = function (lhs, rhs) {\n    LessThanOperation.superclass.init.call(this, lhs, rhs);\n  };\n  LessThanOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));\n  };\n  LessThanOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" < \" + this.rhs.toString() + \")\";\n  };\n\n  // GreaterThanOperation //////////////////////////////////////////////////////\n\n  GreaterThanOperation.prototype = new BinaryOperation();\n  GreaterThanOperation.prototype.constructor = GreaterThanOperation;\n  GreaterThanOperation.superclass = BinaryOperation.prototype;\n  function GreaterThanOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  GreaterThanOperation.prototype.init = function (lhs, rhs) {\n    GreaterThanOperation.superclass.init.call(this, lhs, rhs);\n  };\n  GreaterThanOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));\n  };\n  GreaterThanOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" > \" + this.rhs.toString() + \")\";\n  };\n\n  // LessThanOrEqualOperation //////////////////////////////////////////////////\n\n  LessThanOrEqualOperation.prototype = new BinaryOperation();\n  LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;\n  LessThanOrEqualOperation.superclass = BinaryOperation.prototype;\n  function LessThanOrEqualOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  LessThanOrEqualOperation.prototype.init = function (lhs, rhs) {\n    LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);\n  };\n  LessThanOrEqualOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));\n  };\n  LessThanOrEqualOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" <= \" + this.rhs.toString() + \")\";\n  };\n\n  // GreaterThanOrEqualOperation ///////////////////////////////////////////////\n\n  GreaterThanOrEqualOperation.prototype = new BinaryOperation();\n  GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;\n  GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;\n  function GreaterThanOrEqualOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  GreaterThanOrEqualOperation.prototype.init = function (lhs, rhs) {\n    GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);\n  };\n  GreaterThanOrEqualOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));\n  };\n  GreaterThanOrEqualOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" >= \" + this.rhs.toString() + \")\";\n  };\n\n  // PlusOperation /////////////////////////////////////////////////////////////\n\n  PlusOperation.prototype = new BinaryOperation();\n  PlusOperation.prototype.constructor = PlusOperation;\n  PlusOperation.superclass = BinaryOperation.prototype;\n  function PlusOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  PlusOperation.prototype.init = function (lhs, rhs) {\n    PlusOperation.superclass.init.call(this, lhs, rhs);\n  };\n  PlusOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());\n  };\n  PlusOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" + \" + this.rhs.toString() + \")\";\n  };\n\n  // MinusOperation ////////////////////////////////////////////////////////////\n\n  MinusOperation.prototype = new BinaryOperation();\n  MinusOperation.prototype.constructor = MinusOperation;\n  MinusOperation.superclass = BinaryOperation.prototype;\n  function MinusOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  MinusOperation.prototype.init = function (lhs, rhs) {\n    MinusOperation.superclass.init.call(this, lhs, rhs);\n  };\n  MinusOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());\n  };\n  MinusOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" - \" + this.rhs.toString() + \")\";\n  };\n\n  // MultiplyOperation /////////////////////////////////////////////////////////\n\n  MultiplyOperation.prototype = new BinaryOperation();\n  MultiplyOperation.prototype.constructor = MultiplyOperation;\n  MultiplyOperation.superclass = BinaryOperation.prototype;\n  function MultiplyOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  MultiplyOperation.prototype.init = function (lhs, rhs) {\n    MultiplyOperation.superclass.init.call(this, lhs, rhs);\n  };\n  MultiplyOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());\n  };\n  MultiplyOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" * \" + this.rhs.toString() + \")\";\n  };\n\n  // DivOperation //////////////////////////////////////////////////////////////\n\n  DivOperation.prototype = new BinaryOperation();\n  DivOperation.prototype.constructor = DivOperation;\n  DivOperation.superclass = BinaryOperation.prototype;\n  function DivOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  DivOperation.prototype.init = function (lhs, rhs) {\n    DivOperation.superclass.init.call(this, lhs, rhs);\n  };\n  DivOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());\n  };\n  DivOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" div \" + this.rhs.toString() + \")\";\n  };\n\n  // ModOperation //////////////////////////////////////////////////////////////\n\n  ModOperation.prototype = new BinaryOperation();\n  ModOperation.prototype.constructor = ModOperation;\n  ModOperation.superclass = BinaryOperation.prototype;\n  function ModOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  ModOperation.prototype.init = function (lhs, rhs) {\n    ModOperation.superclass.init.call(this, lhs, rhs);\n  };\n  ModOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());\n  };\n  ModOperation.prototype.toString = function () {\n    return \"(\" + this.lhs.toString() + \" mod \" + this.rhs.toString() + \")\";\n  };\n\n  // BarOperation //////////////////////////////////////////////////////////////\n\n  BarOperation.prototype = new BinaryOperation();\n  BarOperation.prototype.constructor = BarOperation;\n  BarOperation.superclass = BinaryOperation.prototype;\n  function BarOperation(lhs, rhs) {\n    if (arguments.length > 0) {\n      this.init(lhs, rhs);\n    }\n  }\n  BarOperation.prototype.init = function (lhs, rhs) {\n    BarOperation.superclass.init.call(this, lhs, rhs);\n  };\n  BarOperation.prototype.evaluate = function (c) {\n    return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());\n  };\n  BarOperation.prototype.toString = function () {\n    return this.lhs.toString() + \" | \" + this.rhs.toString();\n  };\n\n  // PathExpr //////////////////////////////////////////////////////////////////\n\n  PathExpr.prototype = new Expression();\n  PathExpr.prototype.constructor = PathExpr;\n  PathExpr.superclass = Expression.prototype;\n  function PathExpr(filter, filterPreds, locpath) {\n    if (arguments.length > 0) {\n      this.init(filter, filterPreds, locpath);\n    }\n  }\n  PathExpr.prototype.init = function (filter, filterPreds, locpath) {\n    PathExpr.superclass.init.call(this);\n    this.filter = filter;\n    this.filterPredicates = filterPreds;\n    this.locationPath = locpath;\n  };\n\n  /**\r\n   * Returns the topmost node of the tree containing node\r\n   */\n  function findRoot(node) {\n    while (node && node.parentNode) {\n      node = node.parentNode;\n    }\n    return node;\n  }\n  PathExpr.prototype.evaluate = function (c) {\n    var nodes;\n    var xpc = new XPathContext();\n    xpc.variableResolver = c.variableResolver;\n    xpc.functionResolver = c.functionResolver;\n    xpc.namespaceResolver = c.namespaceResolver;\n    xpc.expressionContextNode = c.expressionContextNode;\n    xpc.virtualRoot = c.virtualRoot;\n    xpc.caseInsensitive = c.caseInsensitive;\n    if (this.filter == null) {\n      nodes = [c.contextNode];\n    } else {\n      var ns = this.filter.evaluate(c);\n      if (!Utilities.instance_of(ns, XNodeSet)) {\n        if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {\n          throw new Error(\"Path expression filter must evaluate to a nodset if predicates or location path are used\");\n        }\n        return ns;\n      }\n      nodes = ns.toUnsortedArray();\n      if (this.filterPredicates != null) {\n        // apply each of the predicates in turn\n        for (var j = 0; j < this.filterPredicates.length; j++) {\n          var pred = this.filterPredicates[j];\n          var newNodes = [];\n          xpc.contextSize = nodes.length;\n          for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {\n            xpc.contextNode = nodes[xpc.contextPosition - 1];\n            if (this.predicateMatches(pred, xpc)) {\n              newNodes.push(xpc.contextNode);\n            }\n          }\n          nodes = newNodes;\n        }\n      }\n    }\n    if (this.locationPath != null) {\n      if (this.locationPath.absolute) {\n        if (nodes[0].nodeType != 9 /*Node.DOCUMENT_NODE*/) {\n          if (xpc.virtualRoot != null) {\n            nodes = [xpc.virtualRoot];\n          } else {\n            if (nodes[0].ownerDocument == null) {\n              // IE 5.5 doesn't have ownerDocument?\n              var n = nodes[0];\n              while (n.parentNode != null) {\n                n = n.parentNode;\n              }\n              nodes = [n];\n            } else {\n              nodes = [nodes[0].ownerDocument];\n            }\n          }\n        } else {\n          nodes = [nodes[0]];\n        }\n      }\n      for (var i = 0; i < this.locationPath.steps.length; i++) {\n        var step = this.locationPath.steps[i];\n        var newNodes = [];\n        for (var j = 0; j < nodes.length; j++) {\n          xpc.contextNode = nodes[j];\n          switch (step.axis) {\n            case Step.ANCESTOR:\n              // look at all the ancestor nodes\n              if (xpc.contextNode === xpc.virtualRoot) {\n                break;\n              }\n              var m;\n              if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\n                m = this.getOwnerElement(xpc.contextNode);\n              } else {\n                m = xpc.contextNode.parentNode;\n              }\n              while (m != null) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n                if (m === xpc.virtualRoot) {\n                  break;\n                }\n                m = m.parentNode;\n              }\n              break;\n            case Step.ANCESTORORSELF:\n              // look at all the ancestor nodes and the current node\n              for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? this.getOwnerElement(m) : m.parentNode) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n                if (m === xpc.virtualRoot) {\n                  break;\n                }\n              }\n              break;\n            case Step.ATTRIBUTE:\n              // look at the attributes\n              var nnm = xpc.contextNode.attributes;\n              if (nnm != null) {\n                for (var k = 0; k < nnm.length; k++) {\n                  var m = nnm.item(k);\n                  if (step.nodeTest.matches(m, xpc)) {\n                    newNodes.push(m);\n                  }\n                }\n              }\n              break;\n            case Step.CHILD:\n              // look at all child elements\n              for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n              }\n              break;\n            case Step.DESCENDANT:\n              // look at all descendant nodes\n              var st = [xpc.contextNode.firstChild];\n              while (st.length > 0) {\n                for (var m = st.pop(); m != null;) {\n                  if (step.nodeTest.matches(m, xpc)) {\n                    newNodes.push(m);\n                  }\n                  if (m.firstChild != null) {\n                    st.push(m.nextSibling);\n                    m = m.firstChild;\n                  } else {\n                    m = m.nextSibling;\n                  }\n                }\n              }\n              break;\n            case Step.DESCENDANTORSELF:\n              // look at self\n              if (step.nodeTest.matches(xpc.contextNode, xpc)) {\n                newNodes.push(xpc.contextNode);\n              }\n              // look at all descendant nodes\n              var st = [xpc.contextNode.firstChild];\n              while (st.length > 0) {\n                for (var m = st.pop(); m != null;) {\n                  if (step.nodeTest.matches(m, xpc)) {\n                    newNodes.push(m);\n                  }\n                  if (m.firstChild != null) {\n                    st.push(m.nextSibling);\n                    m = m.firstChild;\n                  } else {\n                    m = m.nextSibling;\n                  }\n                }\n              }\n              break;\n            case Step.FOLLOWING:\n              if (xpc.contextNode === xpc.virtualRoot) {\n                break;\n              }\n              var st = [];\n              if (xpc.contextNode.firstChild != null) {\n                st.unshift(xpc.contextNode.firstChild);\n              } else {\n                st.unshift(xpc.contextNode.nextSibling);\n              }\n              for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {\n                st.unshift(m.nextSibling);\n              }\n              do {\n                for (var m = st.pop(); m != null;) {\n                  if (step.nodeTest.matches(m, xpc)) {\n                    newNodes.push(m);\n                  }\n                  if (m.firstChild != null) {\n                    st.push(m.nextSibling);\n                    m = m.firstChild;\n                  } else {\n                    m = m.nextSibling;\n                  }\n                }\n              } while (st.length > 0);\n              break;\n            case Step.FOLLOWINGSIBLING:\n              if (xpc.contextNode === xpc.virtualRoot) {\n                break;\n              }\n              for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n              }\n              break;\n            case Step.NAMESPACE:\n              var n = {};\n              if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {\n                n[\"xml\"] = XPath.XML_NAMESPACE_URI;\n                n[\"xmlns\"] = XPath.XMLNS_NAMESPACE_URI;\n                for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {\n                  for (var k = 0; k < m.attributes.length; k++) {\n                    var attr = m.attributes.item(k);\n                    var nm = String(attr.name);\n                    if (nm == \"xmlns\") {\n                      if (n[\"\"] == undefined) {\n                        n[\"\"] = attr.value;\n                      }\n                    } else if (nm.length > 6 && nm.substring(0, 6) == \"xmlns:\") {\n                      var pre = nm.substring(6, nm.length);\n                      if (n[pre] == undefined) {\n                        n[pre] = attr.value;\n                      }\n                    }\n                  }\n                }\n                for (var pre in n) {\n                  var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);\n                  if (step.nodeTest.matches(nsn, xpc)) {\n                    newNodes.push(nsn);\n                  }\n                }\n              }\n              break;\n            case Step.PARENT:\n              m = null;\n              if (xpc.contextNode !== xpc.virtualRoot) {\n                if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\n                  m = this.getOwnerElement(xpc.contextNode);\n                } else {\n                  m = xpc.contextNode.parentNode;\n                }\n              }\n              if (m != null && step.nodeTest.matches(m, xpc)) {\n                newNodes.push(m);\n              }\n              break;\n            case Step.PRECEDING:\n              var st;\n              if (xpc.virtualRoot != null) {\n                st = [xpc.virtualRoot];\n              } else {\n                // cannot rely on .ownerDocument because the node may be in a document fragment\n                st = [findRoot(xpc.contextNode)];\n              }\n              outer: while (st.length > 0) {\n                for (var m = st.pop(); m != null;) {\n                  if (m == xpc.contextNode) {\n                    break outer;\n                  }\n                  if (step.nodeTest.matches(m, xpc)) {\n                    newNodes.unshift(m);\n                  }\n                  if (m.firstChild != null) {\n                    st.push(m.nextSibling);\n                    m = m.firstChild;\n                  } else {\n                    m = m.nextSibling;\n                  }\n                }\n              }\n              break;\n            case Step.PRECEDINGSIBLING:\n              if (xpc.contextNode === xpc.virtualRoot) {\n                break;\n              }\n              for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n              }\n              break;\n            case Step.SELF:\n              if (step.nodeTest.matches(xpc.contextNode, xpc)) {\n                newNodes.push(xpc.contextNode);\n              }\n              break;\n            default:\n          }\n        }\n        nodes = newNodes;\n        // apply each of the predicates in turn\n        for (var j = 0; j < step.predicates.length; j++) {\n          var pred = step.predicates[j];\n          var newNodes = [];\n          xpc.contextSize = nodes.length;\n          for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {\n            xpc.contextNode = nodes[xpc.contextPosition - 1];\n            if (this.predicateMatches(pred, xpc)) {\n              newNodes.push(xpc.contextNode);\n            } else {}\n          }\n          nodes = newNodes;\n        }\n      }\n    }\n    var ns = new XNodeSet();\n    ns.addArray(nodes);\n    return ns;\n  };\n  PathExpr.prototype.predicateMatches = function (pred, c) {\n    var res = pred.evaluate(c);\n    if (Utilities.instance_of(res, XNumber)) {\n      return c.contextPosition == res.numberValue();\n    }\n    return res.booleanValue();\n  };\n  PathExpr.prototype.toString = function () {\n    if (this.filter != undefined) {\n      var s = this.filter.toString();\n      if (Utilities.instance_of(this.filter, XString)) {\n        s = \"'\" + s + \"'\";\n      }\n      if (this.filterPredicates != undefined) {\n        for (var i = 0; i < this.filterPredicates.length; i++) {\n          s = s + \"[\" + this.filterPredicates[i].toString() + \"]\";\n        }\n      }\n      if (this.locationPath != undefined) {\n        if (!this.locationPath.absolute) {\n          s += \"/\";\n        }\n        s += this.locationPath.toString();\n      }\n      return s;\n    }\n    return this.locationPath.toString();\n  };\n  PathExpr.prototype.getOwnerElement = function (n) {\n    // DOM 2 has ownerElement\n    if (n.ownerElement) {\n      return n.ownerElement;\n    }\n    // DOM 1 Internet Explorer can use selectSingleNode (ironically)\n    try {\n      if (n.selectSingleNode) {\n        return n.selectSingleNode(\"..\");\n      }\n    } catch (e) {}\n    // Other DOM 1 implementations must use this egregious search\n    var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/ ? n : n.ownerDocument;\n    var elts = doc.getElementsByTagName(\"*\");\n    for (var i = 0; i < elts.length; i++) {\n      var elt = elts.item(i);\n      var nnm = elt.attributes;\n      for (var j = 0; j < nnm.length; j++) {\n        var an = nnm.item(j);\n        if (an === n) {\n          return elt;\n        }\n      }\n    }\n    return null;\n  };\n\n  // LocationPath //////////////////////////////////////////////////////////////\n\n  LocationPath.prototype = new Object();\n  LocationPath.prototype.constructor = LocationPath;\n  LocationPath.superclass = Object.prototype;\n  function LocationPath(abs, steps) {\n    if (arguments.length > 0) {\n      this.init(abs, steps);\n    }\n  }\n  LocationPath.prototype.init = function (abs, steps) {\n    this.absolute = abs;\n    this.steps = steps;\n  };\n  LocationPath.prototype.toString = function () {\n    var s;\n    if (this.absolute) {\n      s = \"/\";\n    } else {\n      s = \"\";\n    }\n    for (var i = 0; i < this.steps.length; i++) {\n      if (i != 0) {\n        s += \"/\";\n      }\n      s += this.steps[i].toString();\n    }\n    return s;\n  };\n\n  // Step //////////////////////////////////////////////////////////////////////\n\n  Step.prototype = new Object();\n  Step.prototype.constructor = Step;\n  Step.superclass = Object.prototype;\n  function Step(axis, nodetest, preds) {\n    if (arguments.length > 0) {\n      this.init(axis, nodetest, preds);\n    }\n  }\n  Step.prototype.init = function (axis, nodetest, preds) {\n    this.axis = axis;\n    this.nodeTest = nodetest;\n    this.predicates = preds;\n  };\n  Step.prototype.toString = function () {\n    var s;\n    switch (this.axis) {\n      case Step.ANCESTOR:\n        s = \"ancestor\";\n        break;\n      case Step.ANCESTORORSELF:\n        s = \"ancestor-or-self\";\n        break;\n      case Step.ATTRIBUTE:\n        s = \"attribute\";\n        break;\n      case Step.CHILD:\n        s = \"child\";\n        break;\n      case Step.DESCENDANT:\n        s = \"descendant\";\n        break;\n      case Step.DESCENDANTORSELF:\n        s = \"descendant-or-self\";\n        break;\n      case Step.FOLLOWING:\n        s = \"following\";\n        break;\n      case Step.FOLLOWINGSIBLING:\n        s = \"following-sibling\";\n        break;\n      case Step.NAMESPACE:\n        s = \"namespace\";\n        break;\n      case Step.PARENT:\n        s = \"parent\";\n        break;\n      case Step.PRECEDING:\n        s = \"preceding\";\n        break;\n      case Step.PRECEDINGSIBLING:\n        s = \"preceding-sibling\";\n        break;\n      case Step.SELF:\n        s = \"self\";\n        break;\n    }\n    s += \"::\";\n    s += this.nodeTest.toString();\n    for (var i = 0; i < this.predicates.length; i++) {\n      s += \"[\" + this.predicates[i].toString() + \"]\";\n    }\n    return s;\n  };\n  Step.ANCESTOR = 0;\n  Step.ANCESTORORSELF = 1;\n  Step.ATTRIBUTE = 2;\n  Step.CHILD = 3;\n  Step.DESCENDANT = 4;\n  Step.DESCENDANTORSELF = 5;\n  Step.FOLLOWING = 6;\n  Step.FOLLOWINGSIBLING = 7;\n  Step.NAMESPACE = 8;\n  Step.PARENT = 9;\n  Step.PRECEDING = 10;\n  Step.PRECEDINGSIBLING = 11;\n  Step.SELF = 12;\n\n  // NodeTest //////////////////////////////////////////////////////////////////\n\n  NodeTest.prototype = new Object();\n  NodeTest.prototype.constructor = NodeTest;\n  NodeTest.superclass = Object.prototype;\n  function NodeTest(type, value) {\n    if (arguments.length > 0) {\n      this.init(type, value);\n    }\n  }\n  NodeTest.prototype.init = function (type, value) {\n    this.type = type;\n    this.value = value;\n  };\n  NodeTest.prototype.toString = function () {\n    switch (this.type) {\n      case NodeTest.NAMETESTANY:\n        return \"*\";\n      case NodeTest.NAMETESTPREFIXANY:\n        return this.value + \":*\";\n      case NodeTest.NAMETESTRESOLVEDANY:\n        return \"{\" + this.value + \"}*\";\n      case NodeTest.NAMETESTQNAME:\n        return this.value;\n      case NodeTest.NAMETESTRESOLVEDNAME:\n        return \"{\" + this.namespaceURI + \"}\" + this.value;\n      case NodeTest.COMMENT:\n        return \"comment()\";\n      case NodeTest.TEXT:\n        return \"text()\";\n      case NodeTest.PI:\n        if (this.value != undefined) {\n          return \"processing-instruction(\\\"\" + this.value + \"\\\")\";\n        }\n        return \"processing-instruction()\";\n      case NodeTest.NODE:\n        return \"node()\";\n    }\n    return \"<unknown nodetest type>\";\n  };\n  NodeTest.prototype.matches = function (n, xpc) {\n    var nType = n.nodeType;\n    switch (this.type) {\n      case NodeTest.NAMETESTANY:\n        if (nType === 2 /*Node.ATTRIBUTE_NODE*/ || nType === 1 /*Node.ELEMENT_NODE*/ || nType === XPathNamespace.XPATH_NAMESPACE_NODE) {\n          return true;\n        }\n        return false;\n      case NodeTest.NAMETESTPREFIXANY:\n        if (nType === 2 /*Node.ATTRIBUTE_NODE*/ || nType === 1 /*Node.ELEMENT_NODE*/) {\n          var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);\n          if (ns == null) {\n            throw new Error(\"Cannot resolve QName \" + this.value);\n          }\n          return ns === (n.namespaceURI || '');\n        }\n        return false;\n      case NodeTest.NAMETESTQNAME:\n        if (nType === 2 /*Node.ATTRIBUTE_NODE*/ || nType === 1 /*Node.ELEMENT_NODE*/ || nType === XPathNamespace.XPATH_NAMESPACE_NODE) {\n          var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);\n          if (test[0] == null) {\n            throw new Error(\"Cannot resolve QName \" + this.value);\n          }\n          test[0] = String(test[0]) || null;\n          test[1] = String(test[1]);\n          var node = [String(n.namespaceURI || '') || null,\n          // localName will be null if the node was created with DOM1 createElement()\n          String(n.localName || n.nodeName)];\n          if (xpc.caseInsensitive) {\n            return test[0] === node[0] && test[1].toLowerCase() === node[1].toLowerCase();\n          }\n          return test[0] === node[0] && test[1] === node[1];\n        }\n        return false;\n      case NodeTest.COMMENT:\n        return nType === 8 /*Node.COMMENT_NODE*/;\n      case NodeTest.TEXT:\n        return nType === 3 /*Node.TEXT_NODE*/ || nType == 4 /*Node.CDATA_SECTION_NODE*/;\n      case NodeTest.PI:\n        return nType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/ && (this.value == null || n.nodeName == this.value);\n      case NodeTest.NODE:\n        return nType === 9 /*Node.DOCUMENT_NODE*/ || nType === 1 /*Node.ELEMENT_NODE*/ || nType === 2 /*Node.ATTRIBUTE_NODE*/ || nType === 3 /*Node.TEXT_NODE*/ || nType === 4 /*Node.CDATA_SECTION_NODE*/ || nType === 8 /*Node.COMMENT_NODE*/ || nType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/;\n    }\n\n    return false;\n  };\n  NodeTest.NAMETESTANY = 0;\n  NodeTest.NAMETESTPREFIXANY = 1;\n  NodeTest.NAMETESTQNAME = 2;\n  NodeTest.COMMENT = 3;\n  NodeTest.TEXT = 4;\n  NodeTest.PI = 5;\n  NodeTest.NODE = 6;\n\n  // VariableReference /////////////////////////////////////////////////////////\n\n  VariableReference.prototype = new Expression();\n  VariableReference.prototype.constructor = VariableReference;\n  VariableReference.superclass = Expression.prototype;\n  function VariableReference(v) {\n    if (arguments.length > 0) {\n      this.init(v);\n    }\n  }\n  VariableReference.prototype.init = function (v) {\n    this.variable = v;\n  };\n  VariableReference.prototype.toString = function () {\n    return \"$\" + this.variable;\n  };\n  VariableReference.prototype.evaluate = function (c) {\n    var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);\n    if (parts[0] == null) {\n      throw new Error(\"Cannot resolve QName \" + fn);\n    }\n    var result = c.variableResolver.getVariable(parts[1], parts[0]);\n    if (!result) {\n      throw XPathException.fromMessage(\"Undeclared variable: \" + this.toString());\n    }\n    return result;\n  };\n\n  // FunctionCall //////////////////////////////////////////////////////////////\n\n  FunctionCall.prototype = new Expression();\n  FunctionCall.prototype.constructor = FunctionCall;\n  FunctionCall.superclass = Expression.prototype;\n  function FunctionCall(fn, args) {\n    if (arguments.length > 0) {\n      this.init(fn, args);\n    }\n  }\n  FunctionCall.prototype.init = function (fn, args) {\n    this.functionName = fn;\n    this.arguments = args;\n  };\n  FunctionCall.prototype.toString = function () {\n    var s = this.functionName + \"(\";\n    for (var i = 0; i < this.arguments.length; i++) {\n      if (i > 0) {\n        s += \", \";\n      }\n      s += this.arguments[i].toString();\n    }\n    return s + \")\";\n  };\n  FunctionCall.prototype.evaluate = function (c) {\n    var f = FunctionResolver.getFunctionFromContext(this.functionName, c);\n    if (!f) {\n      throw new Error(\"Unknown function \" + this.functionName);\n    }\n    var a = [c].concat(this.arguments);\n    return f.apply(c.functionResolver.thisArg, a);\n  };\n\n  // XString ///////////////////////////////////////////////////////////////////\n\n  XString.prototype = new Expression();\n  XString.prototype.constructor = XString;\n  XString.superclass = Expression.prototype;\n  function XString(s) {\n    if (arguments.length > 0) {\n      this.init(s);\n    }\n  }\n  XString.prototype.init = function (s) {\n    this.str = String(s);\n  };\n  XString.prototype.toString = function () {\n    return this.str;\n  };\n  XString.prototype.evaluate = function (c) {\n    return this;\n  };\n  XString.prototype.string = function () {\n    return this;\n  };\n  XString.prototype.number = function () {\n    return new XNumber(this.str);\n  };\n  XString.prototype.bool = function () {\n    return new XBoolean(this.str);\n  };\n  XString.prototype.nodeset = function () {\n    throw new Error(\"Cannot convert string to nodeset\");\n  };\n  XString.prototype.stringValue = function () {\n    return this.str;\n  };\n  XString.prototype.numberValue = function () {\n    return this.number().numberValue();\n  };\n  XString.prototype.booleanValue = function () {\n    return this.bool().booleanValue();\n  };\n  XString.prototype.equals = function (r) {\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.bool().equals(r);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.number().equals(r);\n    }\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithString(this, Operators.equals);\n    }\n    return new XBoolean(this.str == r.str);\n  };\n  XString.prototype.notequal = function (r) {\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.bool().notequal(r);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.number().notequal(r);\n    }\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithString(this, Operators.notequal);\n    }\n    return new XBoolean(this.str != r.str);\n  };\n  XString.prototype.lessthan = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.greaterthanorequal);\n    }\n    return this.number().lessthan(r.number());\n  };\n  XString.prototype.greaterthan = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.lessthanorequal);\n    }\n    return this.number().greaterthan(r.number());\n  };\n  XString.prototype.lessthanorequal = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.greaterthan);\n    }\n    return this.number().lessthanorequal(r.number());\n  };\n  XString.prototype.greaterthanorequal = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.lessthan);\n    }\n    return this.number().greaterthanorequal(r.number());\n  };\n\n  // XNumber ///////////////////////////////////////////////////////////////////\n\n  XNumber.prototype = new Expression();\n  XNumber.prototype.constructor = XNumber;\n  XNumber.superclass = Expression.prototype;\n  function XNumber(n) {\n    if (arguments.length > 0) {\n      this.init(n);\n    }\n  }\n  XNumber.prototype.init = function (n) {\n    this.num = typeof n === \"string\" ? this.parse(n) : Number(n);\n  };\n  XNumber.prototype.numberFormat = /^\\s*-?[0-9]*\\.?[0-9]+\\s*$/;\n  XNumber.prototype.parse = function (s) {\n    // XPath representation of numbers is more restrictive than what Number() or parseFloat() allow\n    return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;\n  };\n  function padSmallNumber(numberStr) {\n    var parts = numberStr.split('e-');\n    var base = parts[0].replace('.', '');\n    var exponent = Number(parts[1]);\n    for (var i = 0; i < exponent - 1; i += 1) {\n      base = '0' + base;\n    }\n    return '0.' + base;\n  }\n  function padLargeNumber(numberStr) {\n    var parts = numberStr.split('e');\n    var base = parts[0].replace('.', '');\n    var exponent = Number(parts[1]);\n    var zerosToAppend = exponent + 1 - base.length;\n    for (var i = 0; i < zerosToAppend; i += 1) {\n      base += '0';\n    }\n    return base;\n  }\n  XNumber.prototype.toString = function () {\n    var strValue = this.num.toString();\n    if (strValue.indexOf('e-') !== -1) {\n      return padSmallNumber(strValue);\n    }\n    if (strValue.indexOf('e') !== -1) {\n      return padLargeNumber(strValue);\n    }\n    return strValue;\n  };\n  XNumber.prototype.evaluate = function (c) {\n    return this;\n  };\n  XNumber.prototype.string = function () {\n    return new XString(this.toString());\n  };\n  XNumber.prototype.number = function () {\n    return this;\n  };\n  XNumber.prototype.bool = function () {\n    return new XBoolean(this.num);\n  };\n  XNumber.prototype.nodeset = function () {\n    throw new Error(\"Cannot convert number to nodeset\");\n  };\n  XNumber.prototype.stringValue = function () {\n    return this.string().stringValue();\n  };\n  XNumber.prototype.numberValue = function () {\n    return this.num;\n  };\n  XNumber.prototype.booleanValue = function () {\n    return this.bool().booleanValue();\n  };\n  XNumber.prototype.negate = function () {\n    return new XNumber(-this.num);\n  };\n  XNumber.prototype.equals = function (r) {\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.bool().equals(r);\n    }\n    if (Utilities.instance_of(r, XString)) {\n      return this.equals(r.number());\n    }\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this, Operators.equals);\n    }\n    return new XBoolean(this.num == r.num);\n  };\n  XNumber.prototype.notequal = function (r) {\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.bool().notequal(r);\n    }\n    if (Utilities.instance_of(r, XString)) {\n      return this.notequal(r.number());\n    }\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this, Operators.notequal);\n    }\n    return new XBoolean(this.num != r.num);\n  };\n  XNumber.prototype.lessthan = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this, Operators.greaterthanorequal);\n    }\n    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n      return this.lessthan(r.number());\n    }\n    return new XBoolean(this.num < r.num);\n  };\n  XNumber.prototype.greaterthan = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this, Operators.lessthanorequal);\n    }\n    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n      return this.greaterthan(r.number());\n    }\n    return new XBoolean(this.num > r.num);\n  };\n  XNumber.prototype.lessthanorequal = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this, Operators.greaterthan);\n    }\n    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n      return this.lessthanorequal(r.number());\n    }\n    return new XBoolean(this.num <= r.num);\n  };\n  XNumber.prototype.greaterthanorequal = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this, Operators.lessthan);\n    }\n    if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n      return this.greaterthanorequal(r.number());\n    }\n    return new XBoolean(this.num >= r.num);\n  };\n  XNumber.prototype.plus = function (r) {\n    return new XNumber(this.num + r.num);\n  };\n  XNumber.prototype.minus = function (r) {\n    return new XNumber(this.num - r.num);\n  };\n  XNumber.prototype.multiply = function (r) {\n    return new XNumber(this.num * r.num);\n  };\n  XNumber.prototype.div = function (r) {\n    return new XNumber(this.num / r.num);\n  };\n  XNumber.prototype.mod = function (r) {\n    return new XNumber(this.num % r.num);\n  };\n\n  // XBoolean //////////////////////////////////////////////////////////////////\n\n  XBoolean.prototype = new Expression();\n  XBoolean.prototype.constructor = XBoolean;\n  XBoolean.superclass = Expression.prototype;\n  function XBoolean(b) {\n    if (arguments.length > 0) {\n      this.init(b);\n    }\n  }\n  XBoolean.prototype.init = function (b) {\n    this.b = Boolean(b);\n  };\n  XBoolean.prototype.toString = function () {\n    return this.b.toString();\n  };\n  XBoolean.prototype.evaluate = function (c) {\n    return this;\n  };\n  XBoolean.prototype.string = function () {\n    return new XString(this.b);\n  };\n  XBoolean.prototype.number = function () {\n    return new XNumber(this.b);\n  };\n  XBoolean.prototype.bool = function () {\n    return this;\n  };\n  XBoolean.prototype.nodeset = function () {\n    throw new Error(\"Cannot convert boolean to nodeset\");\n  };\n  XBoolean.prototype.stringValue = function () {\n    return this.string().stringValue();\n  };\n  XBoolean.prototype.numberValue = function () {\n    return this.num().numberValue();\n  };\n  XBoolean.prototype.booleanValue = function () {\n    return this.b;\n  };\n  XBoolean.prototype.not = function () {\n    return new XBoolean(!this.b);\n  };\n  XBoolean.prototype.equals = function (r) {\n    if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {\n      return this.equals(r.bool());\n    }\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithBoolean(this, Operators.equals);\n    }\n    return new XBoolean(this.b == r.b);\n  };\n  XBoolean.prototype.notequal = function (r) {\n    if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {\n      return this.notequal(r.bool());\n    }\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithBoolean(this, Operators.notequal);\n    }\n    return new XBoolean(this.b != r.b);\n  };\n  XBoolean.prototype.lessthan = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.greaterthanorequal);\n    }\n    return this.number().lessthan(r.number());\n  };\n  XBoolean.prototype.greaterthan = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.lessthanorequal);\n    }\n    return this.number().greaterthan(r.number());\n  };\n  XBoolean.prototype.lessthanorequal = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.greaterthan);\n    }\n    return this.number().lessthanorequal(r.number());\n  };\n  XBoolean.prototype.greaterthanorequal = function (r) {\n    if (Utilities.instance_of(r, XNodeSet)) {\n      return r.compareWithNumber(this.number(), Operators.lessthan);\n    }\n    return this.number().greaterthanorequal(r.number());\n  };\n\n  // AVLTree ///////////////////////////////////////////////////////////////////\n\n  AVLTree.prototype = new Object();\n  AVLTree.prototype.constructor = AVLTree;\n  AVLTree.superclass = Object.prototype;\n  function AVLTree(n) {\n    this.init(n);\n  }\n  AVLTree.prototype.init = function (n) {\n    this.left = null;\n    this.right = null;\n    this.node = n;\n    this.depth = 1;\n  };\n  AVLTree.prototype.balance = function () {\n    var ldepth = this.left == null ? 0 : this.left.depth;\n    var rdepth = this.right == null ? 0 : this.right.depth;\n    if (ldepth > rdepth + 1) {\n      // LR or LL rotation\n      var lldepth = this.left.left == null ? 0 : this.left.left.depth;\n      var lrdepth = this.left.right == null ? 0 : this.left.right.depth;\n      if (lldepth < lrdepth) {\n        // LR rotation consists of a RR rotation of the left child\n        this.left.rotateRR();\n        // plus a LL rotation of this node, which happens anyway\n      }\n\n      this.rotateLL();\n    } else if (ldepth + 1 < rdepth) {\n      // RR or RL rorarion\n      var rrdepth = this.right.right == null ? 0 : this.right.right.depth;\n      var rldepth = this.right.left == null ? 0 : this.right.left.depth;\n      if (rldepth > rrdepth) {\n        // RR rotation consists of a LL rotation of the right child\n        this.right.rotateLL();\n        // plus a RR rotation of this node, which happens anyway\n      }\n\n      this.rotateRR();\n    }\n  };\n  AVLTree.prototype.rotateLL = function () {\n    // the left side is too long => rotate from the left (_not_ leftwards)\n    var nodeBefore = this.node;\n    var rightBefore = this.right;\n    this.node = this.left.node;\n    this.right = this.left;\n    this.left = this.left.left;\n    this.right.left = this.right.right;\n    this.right.right = rightBefore;\n    this.right.node = nodeBefore;\n    this.right.updateInNewLocation();\n    this.updateInNewLocation();\n  };\n  AVLTree.prototype.rotateRR = function () {\n    // the right side is too long => rotate from the right (_not_ rightwards)\n    var nodeBefore = this.node;\n    var leftBefore = this.left;\n    this.node = this.right.node;\n    this.left = this.right;\n    this.right = this.right.right;\n    this.left.right = this.left.left;\n    this.left.left = leftBefore;\n    this.left.node = nodeBefore;\n    this.left.updateInNewLocation();\n    this.updateInNewLocation();\n  };\n  AVLTree.prototype.updateInNewLocation = function () {\n    this.getDepthFromChildren();\n  };\n  AVLTree.prototype.getDepthFromChildren = function () {\n    this.depth = this.node == null ? 0 : 1;\n    if (this.left != null) {\n      this.depth = this.left.depth + 1;\n    }\n    if (this.right != null && this.depth <= this.right.depth) {\n      this.depth = this.right.depth + 1;\n    }\n  };\n  function nodeOrder(n1, n2) {\n    if (n1 === n2) {\n      return 0;\n    }\n    if (n1.compareDocumentPosition) {\n      var cpos = n1.compareDocumentPosition(n2);\n      if (cpos & 0x01) {\n        // not in the same document; return an arbitrary result (is there a better way to do this)\n        return 1;\n      }\n      if (cpos & 0x0A) {\n        // n2 precedes or contains n1\n        return 1;\n      }\n      if (cpos & 0x14) {\n        // n2 follows or is contained by n1\n        return -1;\n      }\n      return 0;\n    }\n    var d1 = 0,\n      d2 = 0;\n    for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {\n      d1++;\n    }\n    for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {\n      d2++;\n    }\n\n    // step up to same depth\n    if (d1 > d2) {\n      while (d1 > d2) {\n        n1 = n1.parentNode || n1.ownerElement;\n        d1--;\n      }\n      if (n1 === n2) {\n        return 1;\n      }\n    } else if (d2 > d1) {\n      while (d2 > d1) {\n        n2 = n2.parentNode || n2.ownerElement;\n        d2--;\n      }\n      if (n1 === n2) {\n        return -1;\n      }\n    }\n    var n1Par = n1.parentNode || n1.ownerElement,\n      n2Par = n2.parentNode || n2.ownerElement;\n\n    // find common parent\n    while (n1Par !== n2Par) {\n      n1 = n1Par;\n      n2 = n2Par;\n      n1Par = n1.parentNode || n1.ownerElement;\n      n2Par = n2.parentNode || n2.ownerElement;\n    }\n    var n1isAttr = Utilities.isAttribute(n1);\n    var n2isAttr = Utilities.isAttribute(n2);\n    if (n1isAttr && !n2isAttr) {\n      return -1;\n    }\n    if (!n1isAttr && n2isAttr) {\n      return 1;\n    }\n    if (n1Par) {\n      var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes,\n        len = cn.length;\n      for (var i = 0; i < len; i += 1) {\n        var n = cn[i];\n        if (n === n1) {\n          return -1;\n        }\n        if (n === n2) {\n          return 1;\n        }\n      }\n    }\n    throw new Error('Unexpected: could not determine node order');\n  }\n  AVLTree.prototype.add = function (n) {\n    if (n === this.node) {\n      return false;\n    }\n    var o = nodeOrder(n, this.node);\n    var ret = false;\n    if (o == -1) {\n      if (this.left == null) {\n        this.left = new AVLTree(n);\n        ret = true;\n      } else {\n        ret = this.left.add(n);\n        if (ret) {\n          this.balance();\n        }\n      }\n    } else if (o == 1) {\n      if (this.right == null) {\n        this.right = new AVLTree(n);\n        ret = true;\n      } else {\n        ret = this.right.add(n);\n        if (ret) {\n          this.balance();\n        }\n      }\n    }\n    if (ret) {\n      this.getDepthFromChildren();\n    }\n    return ret;\n  };\n\n  // XNodeSet //////////////////////////////////////////////////////////////////\n\n  XNodeSet.prototype = new Expression();\n  XNodeSet.prototype.constructor = XNodeSet;\n  XNodeSet.superclass = Expression.prototype;\n  function XNodeSet() {\n    this.init();\n  }\n  XNodeSet.prototype.init = function () {\n    this.tree = null;\n    this.nodes = [];\n    this.size = 0;\n  };\n  XNodeSet.prototype.toString = function () {\n    var p = this.first();\n    if (p == null) {\n      return \"\";\n    }\n    return this.stringForNode(p);\n  };\n  XNodeSet.prototype.evaluate = function (c) {\n    return this;\n  };\n  XNodeSet.prototype.string = function () {\n    return new XString(this.toString());\n  };\n  XNodeSet.prototype.stringValue = function () {\n    return this.toString();\n  };\n  XNodeSet.prototype.number = function () {\n    return new XNumber(this.string());\n  };\n  XNodeSet.prototype.numberValue = function () {\n    return Number(this.string());\n  };\n  XNodeSet.prototype.bool = function () {\n    return new XBoolean(this.booleanValue());\n  };\n  XNodeSet.prototype.booleanValue = function () {\n    return !!this.size;\n  };\n  XNodeSet.prototype.nodeset = function () {\n    return this;\n  };\n  XNodeSet.prototype.stringForNode = function (n) {\n    if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/ || n.nodeType == 1 /*Node.ELEMENT_NODE */ || n.nodeType === 11 /*Node.DOCUMENT_FRAGMENT*/) {\n      return this.stringForContainerNode(n);\n    }\n    if (n.nodeType === 2 /* Node.ATTRIBUTE_NODE */) {\n      return n.value || n.nodeValue;\n    }\n    if (n.isNamespaceNode) {\n      return n.namespace;\n    }\n    return n.nodeValue;\n  };\n  XNodeSet.prototype.stringForContainerNode = function (n) {\n    var s = \"\";\n    for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {\n      var nt = n2.nodeType;\n      //  Element,    Text,       CDATA,      Document,   Document Fragment\n      if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {\n        s += this.stringForNode(n2);\n      }\n    }\n    return s;\n  };\n  XNodeSet.prototype.buildTree = function () {\n    if (!this.tree && this.nodes.length) {\n      this.tree = new AVLTree(this.nodes[0]);\n      for (var i = 1; i < this.nodes.length; i += 1) {\n        this.tree.add(this.nodes[i]);\n      }\n    }\n    return this.tree;\n  };\n  XNodeSet.prototype.first = function () {\n    var p = this.buildTree();\n    if (p == null) {\n      return null;\n    }\n    while (p.left != null) {\n      p = p.left;\n    }\n    return p.node;\n  };\n  XNodeSet.prototype.add = function (n) {\n    for (var i = 0; i < this.nodes.length; i += 1) {\n      if (n === this.nodes[i]) {\n        return;\n      }\n    }\n    this.tree = null;\n    this.nodes.push(n);\n    this.size += 1;\n  };\n  XNodeSet.prototype.addArray = function (ns) {\n    for (var i = 0; i < ns.length; i += 1) {\n      this.add(ns[i]);\n    }\n  };\n\n  /**\r\n   * Returns an array of the node set's contents in document order\r\n   */\n  XNodeSet.prototype.toArray = function () {\n    var a = [];\n    this.toArrayRec(this.buildTree(), a);\n    return a;\n  };\n  XNodeSet.prototype.toArrayRec = function (t, a) {\n    if (t != null) {\n      this.toArrayRec(t.left, a);\n      a.push(t.node);\n      this.toArrayRec(t.right, a);\n    }\n  };\n\n  /**\r\n   * Returns an array of the node set's contents in arbitrary order\r\n   */\n  XNodeSet.prototype.toUnsortedArray = function () {\n    return this.nodes.slice();\n  };\n  XNodeSet.prototype.compareWithString = function (r, o) {\n    var a = this.toUnsortedArray();\n    for (var i = 0; i < a.length; i++) {\n      var n = a[i];\n      var l = new XString(this.stringForNode(n));\n      var res = o(l, r);\n      if (res.booleanValue()) {\n        return res;\n      }\n    }\n    return new XBoolean(false);\n  };\n  XNodeSet.prototype.compareWithNumber = function (r, o) {\n    var a = this.toUnsortedArray();\n    for (var i = 0; i < a.length; i++) {\n      var n = a[i];\n      var l = new XNumber(this.stringForNode(n));\n      var res = o(l, r);\n      if (res.booleanValue()) {\n        return res;\n      }\n    }\n    return new XBoolean(false);\n  };\n  XNodeSet.prototype.compareWithBoolean = function (r, o) {\n    return o(this.bool(), r);\n  };\n  XNodeSet.prototype.compareWithNodeSet = function (r, o) {\n    var arr = this.toUnsortedArray();\n    var oInvert = function oInvert(lop, rop) {\n      return o(rop, lop);\n    };\n    for (var i = 0; i < arr.length; i++) {\n      var l = new XString(this.stringForNode(arr[i]));\n      var res = r.compareWithString(l, oInvert);\n      if (res.booleanValue()) {\n        return res;\n      }\n    }\n    return new XBoolean(false);\n  };\n  XNodeSet.prototype.equals = function (r) {\n    if (Utilities.instance_of(r, XString)) {\n      return this.compareWithString(r, Operators.equals);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.compareWithNumber(r, Operators.equals);\n    }\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.compareWithBoolean(r, Operators.equals);\n    }\n    return this.compareWithNodeSet(r, Operators.equals);\n  };\n  XNodeSet.prototype.notequal = function (r) {\n    if (Utilities.instance_of(r, XString)) {\n      return this.compareWithString(r, Operators.notequal);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.compareWithNumber(r, Operators.notequal);\n    }\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.compareWithBoolean(r, Operators.notequal);\n    }\n    return this.compareWithNodeSet(r, Operators.notequal);\n  };\n  XNodeSet.prototype.lessthan = function (r) {\n    if (Utilities.instance_of(r, XString)) {\n      return this.compareWithNumber(r.number(), Operators.lessthan);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.compareWithNumber(r, Operators.lessthan);\n    }\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.compareWithBoolean(r, Operators.lessthan);\n    }\n    return this.compareWithNodeSet(r, Operators.lessthan);\n  };\n  XNodeSet.prototype.greaterthan = function (r) {\n    if (Utilities.instance_of(r, XString)) {\n      return this.compareWithNumber(r.number(), Operators.greaterthan);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.compareWithNumber(r, Operators.greaterthan);\n    }\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.compareWithBoolean(r, Operators.greaterthan);\n    }\n    return this.compareWithNodeSet(r, Operators.greaterthan);\n  };\n  XNodeSet.prototype.lessthanorequal = function (r) {\n    if (Utilities.instance_of(r, XString)) {\n      return this.compareWithNumber(r.number(), Operators.lessthanorequal);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.compareWithNumber(r, Operators.lessthanorequal);\n    }\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.compareWithBoolean(r, Operators.lessthanorequal);\n    }\n    return this.compareWithNodeSet(r, Operators.lessthanorequal);\n  };\n  XNodeSet.prototype.greaterthanorequal = function (r) {\n    if (Utilities.instance_of(r, XString)) {\n      return this.compareWithNumber(r.number(), Operators.greaterthanorequal);\n    }\n    if (Utilities.instance_of(r, XNumber)) {\n      return this.compareWithNumber(r, Operators.greaterthanorequal);\n    }\n    if (Utilities.instance_of(r, XBoolean)) {\n      return this.compareWithBoolean(r, Operators.greaterthanorequal);\n    }\n    return this.compareWithNodeSet(r, Operators.greaterthanorequal);\n  };\n  XNodeSet.prototype.union = function (r) {\n    var ns = new XNodeSet();\n    ns.addArray(this.toUnsortedArray());\n    ns.addArray(r.toUnsortedArray());\n    return ns;\n  };\n\n  // XPathNamespace ////////////////////////////////////////////////////////////\n\n  XPathNamespace.prototype = new Object();\n  XPathNamespace.prototype.constructor = XPathNamespace;\n  XPathNamespace.superclass = Object.prototype;\n  function XPathNamespace(pre, ns, p) {\n    this.isXPathNamespace = true;\n    this.ownerDocument = p.ownerDocument;\n    this.nodeName = \"#namespace\";\n    this.prefix = pre;\n    this.localName = pre;\n    this.namespaceURI = ns;\n    this.nodeValue = ns;\n    this.ownerElement = p;\n    this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;\n  }\n  XPathNamespace.prototype.toString = function () {\n    return \"{ \\\"\" + this.prefix + \"\\\", \\\"\" + this.namespaceURI + \"\\\" }\";\n  };\n\n  // Operators /////////////////////////////////////////////////////////////////\n\n  var Operators = new Object();\n  Operators.equals = function (l, r) {\n    return l.equals(r);\n  };\n  Operators.notequal = function (l, r) {\n    return l.notequal(r);\n  };\n  Operators.lessthan = function (l, r) {\n    return l.lessthan(r);\n  };\n  Operators.greaterthan = function (l, r) {\n    return l.greaterthan(r);\n  };\n  Operators.lessthanorequal = function (l, r) {\n    return l.lessthanorequal(r);\n  };\n  Operators.greaterthanorequal = function (l, r) {\n    return l.greaterthanorequal(r);\n  };\n\n  // XPathContext //////////////////////////////////////////////////////////////\n\n  XPathContext.prototype = new Object();\n  XPathContext.prototype.constructor = XPathContext;\n  XPathContext.superclass = Object.prototype;\n  function XPathContext(vr, nr, fr) {\n    this.variableResolver = vr != null ? vr : new VariableResolver();\n    this.namespaceResolver = nr != null ? nr : new NamespaceResolver();\n    this.functionResolver = fr != null ? fr : new FunctionResolver();\n  }\n\n  // VariableResolver //////////////////////////////////////////////////////////\n\n  VariableResolver.prototype = new Object();\n  VariableResolver.prototype.constructor = VariableResolver;\n  VariableResolver.superclass = Object.prototype;\n  function VariableResolver() {}\n  VariableResolver.prototype.getVariable = function (ln, ns) {\n    return null;\n  };\n\n  // FunctionResolver //////////////////////////////////////////////////////////\n\n  FunctionResolver.prototype = new Object();\n  FunctionResolver.prototype.constructor = FunctionResolver;\n  FunctionResolver.superclass = Object.prototype;\n  function FunctionResolver(thisArg) {\n    this.thisArg = thisArg != null ? thisArg : Functions;\n    this.functions = new Object();\n    this.addStandardFunctions();\n  }\n  FunctionResolver.prototype.addStandardFunctions = function () {\n    this.functions[\"{}last\"] = Functions.last;\n    this.functions[\"{}position\"] = Functions.position;\n    this.functions[\"{}count\"] = Functions.count;\n    this.functions[\"{}id\"] = Functions.id;\n    this.functions[\"{}local-name\"] = Functions.localName;\n    this.functions[\"{}namespace-uri\"] = Functions.namespaceURI;\n    this.functions[\"{}name\"] = Functions.name;\n    this.functions[\"{}string\"] = Functions.string;\n    this.functions[\"{}concat\"] = Functions.concat;\n    this.functions[\"{}starts-with\"] = Functions.startsWith;\n    this.functions[\"{}contains\"] = Functions.contains;\n    this.functions[\"{}substring-before\"] = Functions.substringBefore;\n    this.functions[\"{}substring-after\"] = Functions.substringAfter;\n    this.functions[\"{}substring\"] = Functions.substring;\n    this.functions[\"{}string-length\"] = Functions.stringLength;\n    this.functions[\"{}normalize-space\"] = Functions.normalizeSpace;\n    this.functions[\"{}translate\"] = Functions.translate;\n    this.functions[\"{}boolean\"] = Functions.boolean_;\n    this.functions[\"{}not\"] = Functions.not;\n    this.functions[\"{}true\"] = Functions.true_;\n    this.functions[\"{}false\"] = Functions.false_;\n    this.functions[\"{}lang\"] = Functions.lang;\n    this.functions[\"{}number\"] = Functions.number;\n    this.functions[\"{}sum\"] = Functions.sum;\n    this.functions[\"{}floor\"] = Functions.floor;\n    this.functions[\"{}ceiling\"] = Functions.ceiling;\n    this.functions[\"{}round\"] = Functions.round;\n  };\n  FunctionResolver.prototype.addFunction = function (ns, ln, f) {\n    this.functions[\"{\" + ns + \"}\" + ln] = f;\n  };\n  FunctionResolver.getFunctionFromContext = function (qName, context) {\n    var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);\n    if (parts[0] === null) {\n      throw new Error(\"Cannot resolve QName \" + name);\n    }\n    return context.functionResolver.getFunction(parts[1], parts[0]);\n  };\n  FunctionResolver.prototype.getFunction = function (localName, namespace) {\n    return this.functions[\"{\" + namespace + \"}\" + localName];\n  };\n\n  // NamespaceResolver /////////////////////////////////////////////////////////\n\n  NamespaceResolver.prototype = new Object();\n  NamespaceResolver.prototype.constructor = NamespaceResolver;\n  NamespaceResolver.superclass = Object.prototype;\n  function NamespaceResolver() {}\n  NamespaceResolver.prototype.getNamespace = function (prefix, n) {\n    if (prefix == \"xml\") {\n      return XPath.XML_NAMESPACE_URI;\n    } else if (prefix == \"xmlns\") {\n      return XPath.XMLNS_NAMESPACE_URI;\n    }\n    if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {\n      n = n.documentElement;\n    } else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\n      n = PathExpr.prototype.getOwnerElement(n);\n    } else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {\n      n = n.parentNode;\n    }\n    while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {\n      var nnm = n.attributes;\n      for (var i = 0; i < nnm.length; i++) {\n        var a = nnm.item(i);\n        var aname = a.name || a.nodeName;\n        if (aname === \"xmlns\" && prefix === \"\" || aname === \"xmlns:\" + prefix) {\n          return String(a.value || a.nodeValue);\n        }\n      }\n      n = n.parentNode;\n    }\n    return null;\n  };\n\n  // Functions /////////////////////////////////////////////////////////////////\n\n  var Functions = new Object();\n  Functions.last = function () {\n    var c = arguments[0];\n    if (arguments.length != 1) {\n      throw new Error(\"Function last expects ()\");\n    }\n    return new XNumber(c.contextSize);\n  };\n  Functions.position = function () {\n    var c = arguments[0];\n    if (arguments.length != 1) {\n      throw new Error(\"Function position expects ()\");\n    }\n    return new XNumber(c.contextPosition);\n  };\n  Functions.count = function () {\n    var c = arguments[0];\n    var ns;\n    if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {\n      throw new Error(\"Function count expects (node-set)\");\n    }\n    return new XNumber(ns.size);\n  };\n  Functions.id = function () {\n    var c = arguments[0];\n    var id;\n    if (arguments.length != 2) {\n      throw new Error(\"Function id expects (object)\");\n    }\n    id = arguments[1].evaluate(c);\n    if (Utilities.instance_of(id, XNodeSet)) {\n      id = id.toArray().join(\" \");\n    } else {\n      id = id.stringValue();\n    }\n    var ids = id.split(/[\\x0d\\x0a\\x09\\x20]+/);\n    var count = 0;\n    var ns = new XNodeSet();\n    var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/ ? c.contextNode : c.contextNode.ownerDocument;\n    for (var i = 0; i < ids.length; i++) {\n      var n;\n      if (doc.getElementById) {\n        n = doc.getElementById(ids[i]);\n      } else {\n        n = Utilities.getElementById(doc, ids[i]);\n      }\n      if (n != null) {\n        ns.add(n);\n        count++;\n      }\n    }\n    return ns;\n  };\n  Functions.localName = function () {\n    var c = arguments[0];\n    var n;\n    if (arguments.length == 1) {\n      n = c.contextNode;\n    } else if (arguments.length == 2) {\n      n = arguments[1].evaluate(c).first();\n    } else {\n      throw new Error(\"Function local-name expects (node-set?)\");\n    }\n    if (n == null) {\n      return new XString(\"\");\n    }\n    return new XString(n.localName ||\n    //  standard elements and attributes\n    n.baseName ||\n    //  IE\n    n.target ||\n    //  processing instructions\n    n.nodeName ||\n    //  DOM1 elements\n    \"\"); //  fallback\n  };\n\n  Functions.namespaceURI = function () {\n    var c = arguments[0];\n    var n;\n    if (arguments.length == 1) {\n      n = c.contextNode;\n    } else if (arguments.length == 2) {\n      n = arguments[1].evaluate(c).first();\n    } else {\n      throw new Error(\"Function namespace-uri expects (node-set?)\");\n    }\n    if (n == null) {\n      return new XString(\"\");\n    }\n    return new XString(n.namespaceURI);\n  };\n  Functions.name = function () {\n    var c = arguments[0];\n    var n;\n    if (arguments.length == 1) {\n      n = c.contextNode;\n    } else if (arguments.length == 2) {\n      n = arguments[1].evaluate(c).first();\n    } else {\n      throw new Error(\"Function name expects (node-set?)\");\n    }\n    if (n == null) {\n      return new XString(\"\");\n    }\n    if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {\n      return new XString(n.nodeName);\n    } else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\n      return new XString(n.name || n.nodeName);\n    } else if (n.nodeType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/) {\n      return new XString(n.target || n.nodeName);\n    } else if (n.localName == null) {\n      return new XString(\"\");\n    } else {\n      return new XString(n.localName);\n    }\n  };\n  Functions.string = function () {\n    var c = arguments[0];\n    if (arguments.length == 1) {\n      return new XString(XNodeSet.prototype.stringForNode(c.contextNode));\n    } else if (arguments.length == 2) {\n      return arguments[1].evaluate(c).string();\n    }\n    throw new Error(\"Function string expects (object?)\");\n  };\n  Functions.concat = function () {\n    var c = arguments[0];\n    if (arguments.length < 3) {\n      throw new Error(\"Function concat expects (string, string, string*)\");\n    }\n    var s = \"\";\n    for (var i = 1; i < arguments.length; i++) {\n      s += arguments[i].evaluate(c).stringValue();\n    }\n    return new XString(s);\n  };\n  Functions.startsWith = function () {\n    var c = arguments[0];\n    if (arguments.length != 3) {\n      throw new Error(\"Function startsWith expects (string, string)\");\n    }\n    var s1 = arguments[1].evaluate(c).stringValue();\n    var s2 = arguments[2].evaluate(c).stringValue();\n    return new XBoolean(s1.substring(0, s2.length) == s2);\n  };\n  Functions.contains = function () {\n    var c = arguments[0];\n    if (arguments.length != 3) {\n      throw new Error(\"Function contains expects (string, string)\");\n    }\n    var s1 = arguments[1].evaluate(c).stringValue();\n    var s2 = arguments[2].evaluate(c).stringValue();\n    return new XBoolean(s1.indexOf(s2) !== -1);\n  };\n  Functions.substringBefore = function () {\n    var c = arguments[0];\n    if (arguments.length != 3) {\n      throw new Error(\"Function substring-before expects (string, string)\");\n    }\n    var s1 = arguments[1].evaluate(c).stringValue();\n    var s2 = arguments[2].evaluate(c).stringValue();\n    return new XString(s1.substring(0, s1.indexOf(s2)));\n  };\n  Functions.substringAfter = function () {\n    var c = arguments[0];\n    if (arguments.length != 3) {\n      throw new Error(\"Function substring-after expects (string, string)\");\n    }\n    var s1 = arguments[1].evaluate(c).stringValue();\n    var s2 = arguments[2].evaluate(c).stringValue();\n    if (s2.length == 0) {\n      return new XString(s1);\n    }\n    var i = s1.indexOf(s2);\n    if (i == -1) {\n      return new XString(\"\");\n    }\n    return new XString(s1.substring(i + s2.length));\n  };\n  Functions.substring = function () {\n    var c = arguments[0];\n    if (!(arguments.length == 3 || arguments.length == 4)) {\n      throw new Error(\"Function substring expects (string, number, number?)\");\n    }\n    var s = arguments[1].evaluate(c).stringValue();\n    var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;\n    var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;\n    return new XString(s.substring(n1, n2));\n  };\n  Functions.stringLength = function () {\n    var c = arguments[0];\n    var s;\n    if (arguments.length == 1) {\n      s = XNodeSet.prototype.stringForNode(c.contextNode);\n    } else if (arguments.length == 2) {\n      s = arguments[1].evaluate(c).stringValue();\n    } else {\n      throw new Error(\"Function string-length expects (string?)\");\n    }\n    return new XNumber(s.length);\n  };\n  Functions.normalizeSpace = function () {\n    var c = arguments[0];\n    var s;\n    if (arguments.length == 1) {\n      s = XNodeSet.prototype.stringForNode(c.contextNode);\n    } else if (arguments.length == 2) {\n      s = arguments[1].evaluate(c).stringValue();\n    } else {\n      throw new Error(\"Function normalize-space expects (string?)\");\n    }\n    var i = 0;\n    var j = s.length - 1;\n    while (Utilities.isSpace(s.charCodeAt(j))) {\n      j--;\n    }\n    var t = \"\";\n    while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {\n      i++;\n    }\n    while (i <= j) {\n      if (Utilities.isSpace(s.charCodeAt(i))) {\n        t += \" \";\n        while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {\n          i++;\n        }\n      } else {\n        t += s.charAt(i);\n        i++;\n      }\n    }\n    return new XString(t);\n  };\n  Functions.translate = function () {\n    var c = arguments[0];\n    if (arguments.length != 4) {\n      throw new Error(\"Function translate expects (string, string, string)\");\n    }\n    var s1 = arguments[1].evaluate(c).stringValue();\n    var s2 = arguments[2].evaluate(c).stringValue();\n    var s3 = arguments[3].evaluate(c).stringValue();\n    var map = [];\n    for (var i = 0; i < s2.length; i++) {\n      var j = s2.charCodeAt(i);\n      if (map[j] == undefined) {\n        var k = i > s3.length ? \"\" : s3.charAt(i);\n        map[j] = k;\n      }\n    }\n    var t = \"\";\n    for (var i = 0; i < s1.length; i++) {\n      var c = s1.charCodeAt(i);\n      var r = map[c];\n      if (r == undefined) {\n        t += s1.charAt(i);\n      } else {\n        t += r;\n      }\n    }\n    return new XString(t);\n  };\n  Functions.boolean_ = function () {\n    var c = arguments[0];\n    if (arguments.length != 2) {\n      throw new Error(\"Function boolean expects (object)\");\n    }\n    return arguments[1].evaluate(c).bool();\n  };\n  Functions.not = function () {\n    var c = arguments[0];\n    if (arguments.length != 2) {\n      throw new Error(\"Function not expects (object)\");\n    }\n    return arguments[1].evaluate(c).bool().not();\n  };\n  Functions.true_ = function () {\n    if (arguments.length != 1) {\n      throw new Error(\"Function true expects ()\");\n    }\n    return new XBoolean(true);\n  };\n  Functions.false_ = function () {\n    if (arguments.length != 1) {\n      throw new Error(\"Function false expects ()\");\n    }\n    return new XBoolean(false);\n  };\n  Functions.lang = function () {\n    var c = arguments[0];\n    if (arguments.length != 2) {\n      throw new Error(\"Function lang expects (string)\");\n    }\n    var lang;\n    for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {\n      var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, \"lang\");\n      if (a != null) {\n        lang = String(a);\n        break;\n      }\n    }\n    if (lang == null) {\n      return new XBoolean(false);\n    }\n    var s = arguments[1].evaluate(c).stringValue();\n    return new XBoolean(lang.substring(0, s.length) == s && (lang.length == s.length || lang.charAt(s.length) == '-'));\n  };\n  Functions.number = function () {\n    var c = arguments[0];\n    if (!(arguments.length == 1 || arguments.length == 2)) {\n      throw new Error(\"Function number expects (object?)\");\n    }\n    if (arguments.length == 1) {\n      return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));\n    }\n    return arguments[1].evaluate(c).number();\n  };\n  Functions.sum = function () {\n    var c = arguments[0];\n    var ns;\n    if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {\n      throw new Error(\"Function sum expects (node-set)\");\n    }\n    ns = ns.toUnsortedArray();\n    var n = 0;\n    for (var i = 0; i < ns.length; i++) {\n      n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();\n    }\n    return new XNumber(n);\n  };\n  Functions.floor = function () {\n    var c = arguments[0];\n    if (arguments.length != 2) {\n      throw new Error(\"Function floor expects (number)\");\n    }\n    return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));\n  };\n  Functions.ceiling = function () {\n    var c = arguments[0];\n    if (arguments.length != 2) {\n      throw new Error(\"Function ceiling expects (number)\");\n    }\n    return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));\n  };\n  Functions.round = function () {\n    var c = arguments[0];\n    if (arguments.length != 2) {\n      throw new Error(\"Function round expects (number)\");\n    }\n    return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));\n  };\n\n  // Utilities /////////////////////////////////////////////////////////////////\n\n  var Utilities = new Object();\n  Utilities.isAttribute = function (val) {\n    return val && (val.nodeType === 2 || val.ownerElement);\n  };\n  Utilities.splitQName = function (qn) {\n    var i = qn.indexOf(\":\");\n    if (i == -1) {\n      return [null, qn];\n    }\n    return [qn.substring(0, i), qn.substring(i + 1)];\n  };\n  Utilities.resolveQName = function (qn, nr, n, useDefault) {\n    var parts = Utilities.splitQName(qn);\n    if (parts[0] != null) {\n      parts[0] = nr.getNamespace(parts[0], n);\n    } else {\n      if (useDefault) {\n        parts[0] = nr.getNamespace(\"\", n);\n        if (parts[0] == null) {\n          parts[0] = \"\";\n        }\n      } else {\n        parts[0] = \"\";\n      }\n    }\n    return parts;\n  };\n  Utilities.isSpace = function (c) {\n    return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;\n  };\n  Utilities.isLetter = function (c) {\n    return c >= 0x0041 && c <= 0x005A || c >= 0x0061 && c <= 0x007A || c >= 0x00C0 && c <= 0x00D6 || c >= 0x00D8 && c <= 0x00F6 || c >= 0x00F8 && c <= 0x00FF || c >= 0x0100 && c <= 0x0131 || c >= 0x0134 && c <= 0x013E || c >= 0x0141 && c <= 0x0148 || c >= 0x014A && c <= 0x017E || c >= 0x0180 && c <= 0x01C3 || c >= 0x01CD && c <= 0x01F0 || c >= 0x01F4 && c <= 0x01F5 || c >= 0x01FA && c <= 0x0217 || c >= 0x0250 && c <= 0x02A8 || c >= 0x02BB && c <= 0x02C1 || c == 0x0386 || c >= 0x0388 && c <= 0x038A || c == 0x038C || c >= 0x038E && c <= 0x03A1 || c >= 0x03A3 && c <= 0x03CE || c >= 0x03D0 && c <= 0x03D6 || c == 0x03DA || c == 0x03DC || c == 0x03DE || c == 0x03E0 || c >= 0x03E2 && c <= 0x03F3 || c >= 0x0401 && c <= 0x040C || c >= 0x040E && c <= 0x044F || c >= 0x0451 && c <= 0x045C || c >= 0x045E && c <= 0x0481 || c >= 0x0490 && c <= 0x04C4 || c >= 0x04C7 && c <= 0x04C8 || c >= 0x04CB && c <= 0x04CC || c >= 0x04D0 && c <= 0x04EB || c >= 0x04EE && c <= 0x04F5 || c >= 0x04F8 && c <= 0x04F9 || c >= 0x0531 && c <= 0x0556 || c == 0x0559 || c >= 0x0561 && c <= 0x0586 || c >= 0x05D0 && c <= 0x05EA || c >= 0x05F0 && c <= 0x05F2 || c >= 0x0621 && c <= 0x063A || c >= 0x0641 && c <= 0x064A || c >= 0x0671 && c <= 0x06B7 || c >= 0x06BA && c <= 0x06BE || c >= 0x06C0 && c <= 0x06CE || c >= 0x06D0 && c <= 0x06D3 || c == 0x06D5 || c >= 0x06E5 && c <= 0x06E6 || c >= 0x0905 && c <= 0x0939 || c == 0x093D || c >= 0x0958 && c <= 0x0961 || c >= 0x0985 && c <= 0x098C || c >= 0x098F && c <= 0x0990 || c >= 0x0993 && c <= 0x09A8 || c >= 0x09AA && c <= 0x09B0 || c == 0x09B2 || c >= 0x09B6 && c <= 0x09B9 || c >= 0x09DC && c <= 0x09DD || c >= 0x09DF && c <= 0x09E1 || c >= 0x09F0 && c <= 0x09F1 || c >= 0x0A05 && c <= 0x0A0A || c >= 0x0A0F && c <= 0x0A10 || c >= 0x0A13 && c <= 0x0A28 || c >= 0x0A2A && c <= 0x0A30 || c >= 0x0A32 && c <= 0x0A33 || c >= 0x0A35 && c <= 0x0A36 || c >= 0x0A38 && c <= 0x0A39 || c >= 0x0A59 && c <= 0x0A5C || c == 0x0A5E || c >= 0x0A72 && c <= 0x0A74 || c >= 0x0A85 && c <= 0x0A8B || c == 0x0A8D || c >= 0x0A8F && c <= 0x0A91 || c >= 0x0A93 && c <= 0x0AA8 || c >= 0x0AAA && c <= 0x0AB0 || c >= 0x0AB2 && c <= 0x0AB3 || c >= 0x0AB5 && c <= 0x0AB9 || c == 0x0ABD || c == 0x0AE0 || c >= 0x0B05 && c <= 0x0B0C || c >= 0x0B0F && c <= 0x0B10 || c >= 0x0B13 && c <= 0x0B28 || c >= 0x0B2A && c <= 0x0B30 || c >= 0x0B32 && c <= 0x0B33 || c >= 0x0B36 && c <= 0x0B39 || c == 0x0B3D || c >= 0x0B5C && c <= 0x0B5D || c >= 0x0B5F && c <= 0x0B61 || c >= 0x0B85 && c <= 0x0B8A || c >= 0x0B8E && c <= 0x0B90 || c >= 0x0B92 && c <= 0x0B95 || c >= 0x0B99 && c <= 0x0B9A || c == 0x0B9C || c >= 0x0B9E && c <= 0x0B9F || c >= 0x0BA3 && c <= 0x0BA4 || c >= 0x0BA8 && c <= 0x0BAA || c >= 0x0BAE && c <= 0x0BB5 || c >= 0x0BB7 && c <= 0x0BB9 || c >= 0x0C05 && c <= 0x0C0C || c >= 0x0C0E && c <= 0x0C10 || c >= 0x0C12 && c <= 0x0C28 || c >= 0x0C2A && c <= 0x0C33 || c >= 0x0C35 && c <= 0x0C39 || c >= 0x0C60 && c <= 0x0C61 || c >= 0x0C85 && c <= 0x0C8C || c >= 0x0C8E && c <= 0x0C90 || c >= 0x0C92 && c <= 0x0CA8 || c >= 0x0CAA && c <= 0x0CB3 || c >= 0x0CB5 && c <= 0x0CB9 || c == 0x0CDE || c >= 0x0CE0 && c <= 0x0CE1 || c >= 0x0D05 && c <= 0x0D0C || c >= 0x0D0E && c <= 0x0D10 || c >= 0x0D12 && c <= 0x0D28 || c >= 0x0D2A && c <= 0x0D39 || c >= 0x0D60 && c <= 0x0D61 || c >= 0x0E01 && c <= 0x0E2E || c == 0x0E30 || c >= 0x0E32 && c <= 0x0E33 || c >= 0x0E40 && c <= 0x0E45 || c >= 0x0E81 && c <= 0x0E82 || c == 0x0E84 || c >= 0x0E87 && c <= 0x0E88 || c == 0x0E8A || c == 0x0E8D || c >= 0x0E94 && c <= 0x0E97 || c >= 0x0E99 && c <= 0x0E9F || c >= 0x0EA1 && c <= 0x0EA3 || c == 0x0EA5 || c == 0x0EA7 || c >= 0x0EAA && c <= 0x0EAB || c >= 0x0EAD && c <= 0x0EAE || c == 0x0EB0 || c >= 0x0EB2 && c <= 0x0EB3 || c == 0x0EBD || c >= 0x0EC0 && c <= 0x0EC4 || c >= 0x0F40 && c <= 0x0F47 || c >= 0x0F49 && c <= 0x0F69 || c >= 0x10A0 && c <= 0x10C5 || c >= 0x10D0 && c <= 0x10F6 || c == 0x1100 || c >= 0x1102 && c <= 0x1103 || c >= 0x1105 && c <= 0x1107 || c == 0x1109 || c >= 0x110B && c <= 0x110C || c >= 0x110E && c <= 0x1112 || c == 0x113C || c == 0x113E || c == 0x1140 || c == 0x114C || c == 0x114E || c == 0x1150 || c >= 0x1154 && c <= 0x1155 || c == 0x1159 || c >= 0x115F && c <= 0x1161 || c == 0x1163 || c == 0x1165 || c == 0x1167 || c == 0x1169 || c >= 0x116D && c <= 0x116E || c >= 0x1172 && c <= 0x1173 || c == 0x1175 || c == 0x119E || c == 0x11A8 || c == 0x11AB || c >= 0x11AE && c <= 0x11AF || c >= 0x11B7 && c <= 0x11B8 || c == 0x11BA || c >= 0x11BC && c <= 0x11C2 || c == 0x11EB || c == 0x11F0 || c == 0x11F9 || c >= 0x1E00 && c <= 0x1E9B || c >= 0x1EA0 && c <= 0x1EF9 || c >= 0x1F00 && c <= 0x1F15 || c >= 0x1F18 && c <= 0x1F1D || c >= 0x1F20 && c <= 0x1F45 || c >= 0x1F48 && c <= 0x1F4D || c >= 0x1F50 && c <= 0x1F57 || c == 0x1F59 || c == 0x1F5B || c == 0x1F5D || c >= 0x1F5F && c <= 0x1F7D || c >= 0x1F80 && c <= 0x1FB4 || c >= 0x1FB6 && c <= 0x1FBC || c == 0x1FBE || c >= 0x1FC2 && c <= 0x1FC4 || c >= 0x1FC6 && c <= 0x1FCC || c >= 0x1FD0 && c <= 0x1FD3 || c >= 0x1FD6 && c <= 0x1FDB || c >= 0x1FE0 && c <= 0x1FEC || c >= 0x1FF2 && c <= 0x1FF4 || c >= 0x1FF6 && c <= 0x1FFC || c == 0x2126 || c >= 0x212A && c <= 0x212B || c == 0x212E || c >= 0x2180 && c <= 0x2182 || c >= 0x3041 && c <= 0x3094 || c >= 0x30A1 && c <= 0x30FA || c >= 0x3105 && c <= 0x312C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0x4E00 && c <= 0x9FA5 || c == 0x3007 || c >= 0x3021 && c <= 0x3029;\n  };\n  Utilities.isNCNameChar = function (c) {\n    return c >= 0x0030 && c <= 0x0039 || c >= 0x0660 && c <= 0x0669 || c >= 0x06F0 && c <= 0x06F9 || c >= 0x0966 && c <= 0x096F || c >= 0x09E6 && c <= 0x09EF || c >= 0x0A66 && c <= 0x0A6F || c >= 0x0AE6 && c <= 0x0AEF || c >= 0x0B66 && c <= 0x0B6F || c >= 0x0BE7 && c <= 0x0BEF || c >= 0x0C66 && c <= 0x0C6F || c >= 0x0CE6 && c <= 0x0CEF || c >= 0x0D66 && c <= 0x0D6F || c >= 0x0E50 && c <= 0x0E59 || c >= 0x0ED0 && c <= 0x0ED9 || c >= 0x0F20 && c <= 0x0F29 || c == 0x002E || c == 0x002D || c == 0x005F || Utilities.isLetter(c) || c >= 0x0300 && c <= 0x0345 || c >= 0x0360 && c <= 0x0361 || c >= 0x0483 && c <= 0x0486 || c >= 0x0591 && c <= 0x05A1 || c >= 0x05A3 && c <= 0x05B9 || c >= 0x05BB && c <= 0x05BD || c == 0x05BF || c >= 0x05C1 && c <= 0x05C2 || c == 0x05C4 || c >= 0x064B && c <= 0x0652 || c == 0x0670 || c >= 0x06D6 && c <= 0x06DC || c >= 0x06DD && c <= 0x06DF || c >= 0x06E0 && c <= 0x06E4 || c >= 0x06E7 && c <= 0x06E8 || c >= 0x06EA && c <= 0x06ED || c >= 0x0901 && c <= 0x0903 || c == 0x093C || c >= 0x093E && c <= 0x094C || c == 0x094D || c >= 0x0951 && c <= 0x0954 || c >= 0x0962 && c <= 0x0963 || c >= 0x0981 && c <= 0x0983 || c == 0x09BC || c == 0x09BE || c == 0x09BF || c >= 0x09C0 && c <= 0x09C4 || c >= 0x09C7 && c <= 0x09C8 || c >= 0x09CB && c <= 0x09CD || c == 0x09D7 || c >= 0x09E2 && c <= 0x09E3 || c == 0x0A02 || c == 0x0A3C || c == 0x0A3E || c == 0x0A3F || c >= 0x0A40 && c <= 0x0A42 || c >= 0x0A47 && c <= 0x0A48 || c >= 0x0A4B && c <= 0x0A4D || c >= 0x0A70 && c <= 0x0A71 || c >= 0x0A81 && c <= 0x0A83 || c == 0x0ABC || c >= 0x0ABE && c <= 0x0AC5 || c >= 0x0AC7 && c <= 0x0AC9 || c >= 0x0ACB && c <= 0x0ACD || c >= 0x0B01 && c <= 0x0B03 || c == 0x0B3C || c >= 0x0B3E && c <= 0x0B43 || c >= 0x0B47 && c <= 0x0B48 || c >= 0x0B4B && c <= 0x0B4D || c >= 0x0B56 && c <= 0x0B57 || c >= 0x0B82 && c <= 0x0B83 || c >= 0x0BBE && c <= 0x0BC2 || c >= 0x0BC6 && c <= 0x0BC8 || c >= 0x0BCA && c <= 0x0BCD || c == 0x0BD7 || c >= 0x0C01 && c <= 0x0C03 || c >= 0x0C3E && c <= 0x0C44 || c >= 0x0C46 && c <= 0x0C48 || c >= 0x0C4A && c <= 0x0C4D || c >= 0x0C55 && c <= 0x0C56 || c >= 0x0C82 && c <= 0x0C83 || c >= 0x0CBE && c <= 0x0CC4 || c >= 0x0CC6 && c <= 0x0CC8 || c >= 0x0CCA && c <= 0x0CCD || c >= 0x0CD5 && c <= 0x0CD6 || c >= 0x0D02 && c <= 0x0D03 || c >= 0x0D3E && c <= 0x0D43 || c >= 0x0D46 && c <= 0x0D48 || c >= 0x0D4A && c <= 0x0D4D || c == 0x0D57 || c == 0x0E31 || c >= 0x0E34 && c <= 0x0E3A || c >= 0x0E47 && c <= 0x0E4E || c == 0x0EB1 || c >= 0x0EB4 && c <= 0x0EB9 || c >= 0x0EBB && c <= 0x0EBC || c >= 0x0EC8 && c <= 0x0ECD || c >= 0x0F18 && c <= 0x0F19 || c == 0x0F35 || c == 0x0F37 || c == 0x0F39 || c == 0x0F3E || c == 0x0F3F || c >= 0x0F71 && c <= 0x0F84 || c >= 0x0F86 && c <= 0x0F8B || c >= 0x0F90 && c <= 0x0F95 || c == 0x0F97 || c >= 0x0F99 && c <= 0x0FAD || c >= 0x0FB1 && c <= 0x0FB7 || c == 0x0FB9 || c >= 0x20D0 && c <= 0x20DC || c == 0x20E1 || c >= 0x302A && c <= 0x302F || c == 0x3099 || c == 0x309A || c == 0x00B7 || c == 0x02D0 || c == 0x02D1 || c == 0x0387 || c == 0x0640 || c == 0x0E46 || c == 0x0EC6 || c == 0x3005 || c >= 0x3031 && c <= 0x3035 || c >= 0x309D && c <= 0x309E || c >= 0x30FC && c <= 0x30FE;\n  };\n  Utilities.coalesceText = function (n) {\n    for (var m = n.firstChild; m != null; m = m.nextSibling) {\n      if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {\n        var s = m.nodeValue;\n        var first = m;\n        m = m.nextSibling;\n        while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {\n          s += m.nodeValue;\n          var del = m;\n          m = m.nextSibling;\n          del.parentNode.removeChild(del);\n        }\n        if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {\n          var p = first.parentNode;\n          if (first.nextSibling == null) {\n            p.removeChild(first);\n            p.appendChild(p.ownerDocument.createTextNode(s));\n          } else {\n            var next = first.nextSibling;\n            p.removeChild(first);\n            p.insertBefore(p.ownerDocument.createTextNode(s), next);\n          }\n        } else {\n          first.nodeValue = s;\n        }\n        if (m == null) {\n          break;\n        }\n      } else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {\n        Utilities.coalesceText(m);\n      }\n    }\n  };\n  Utilities.instance_of = function (o, c) {\n    while (o != null) {\n      if (o.constructor === c) {\n        return true;\n      }\n      if (o === Object) {\n        return false;\n      }\n      o = o.constructor.superclass;\n    }\n    return false;\n  };\n  Utilities.getElementById = function (n, id) {\n    // Note that this does not check the DTD to check for actual\n    // attributes of type ID, so this may be a bit wrong.\n    if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {\n      if (n.getAttribute(\"id\") == id || n.getAttributeNS(null, \"id\") == id) {\n        return n;\n      }\n    }\n    for (var m = n.firstChild; m != null; m = m.nextSibling) {\n      var res = Utilities.getElementById(m, id);\n      if (res != null) {\n        return res;\n      }\n    }\n    return null;\n  };\n\n  // XPathException ////////////////////////////////////////////////////////////\n\n  var XPathException = function () {\n    function getMessage(code, exception) {\n      var msg = exception ? \": \" + exception.toString() : \"\";\n      switch (code) {\n        case XPathException.INVALID_EXPRESSION_ERR:\n          return \"Invalid expression\" + msg;\n        case XPathException.TYPE_ERR:\n          return \"Type error\" + msg;\n      }\n      return null;\n    }\n    function XPathException(code, error, message) {\n      var err = Error.call(this, getMessage(code, error) || message);\n      err.code = code;\n      err.exception = error;\n      return err;\n    }\n    XPathException.prototype = Object.create(Error.prototype);\n    XPathException.prototype.constructor = XPathException;\n    XPathException.superclass = Error;\n    XPathException.prototype.toString = function () {\n      return this.message;\n    };\n    XPathException.fromMessage = function (message, error) {\n      return new XPathException(null, error, message);\n    };\n    XPathException.INVALID_EXPRESSION_ERR = 51;\n    XPathException.TYPE_ERR = 52;\n    return XPathException;\n  }();\n\n  // XPathExpression ///////////////////////////////////////////////////////////\n\n  XPathExpression.prototype = {};\n  XPathExpression.prototype.constructor = XPathExpression;\n  XPathExpression.superclass = Object.prototype;\n  function XPathExpression(e, r, p) {\n    this.xpath = p.parse(e);\n    this.context = new XPathContext();\n    this.context.namespaceResolver = new XPathNSResolverWrapper(r);\n  }\n  XPathExpression.prototype.evaluate = function (n, t, res) {\n    this.context.expressionContextNode = n;\n    var result = this.xpath.evaluate(this.context);\n    return new XPathResult(result, t);\n  };\n\n  // XPathNSResolverWrapper ////////////////////////////////////////////////////\n\n  XPathNSResolverWrapper.prototype = {};\n  XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;\n  XPathNSResolverWrapper.superclass = Object.prototype;\n  function XPathNSResolverWrapper(r) {\n    this.xpathNSResolver = r;\n  }\n  XPathNSResolverWrapper.prototype.getNamespace = function (prefix, n) {\n    if (this.xpathNSResolver == null) {\n      return null;\n    }\n    return this.xpathNSResolver.lookupNamespaceURI(prefix);\n  };\n\n  // NodeXPathNSResolver ///////////////////////////////////////////////////////\n\n  NodeXPathNSResolver.prototype = {};\n  NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;\n  NodeXPathNSResolver.superclass = Object.prototype;\n  function NodeXPathNSResolver(n) {\n    this.node = n;\n    this.namespaceResolver = new NamespaceResolver();\n  }\n  NodeXPathNSResolver.prototype.lookupNamespaceURI = function (prefix) {\n    return this.namespaceResolver.getNamespace(prefix, this.node);\n  };\n\n  // XPathResult ///////////////////////////////////////////////////////////////\n\n  XPathResult.prototype = {};\n  XPathResult.prototype.constructor = XPathResult;\n  XPathResult.superclass = Object.prototype;\n  function XPathResult(v, t) {\n    if (t == XPathResult.ANY_TYPE) {\n      if (v.constructor === XString) {\n        t = XPathResult.STRING_TYPE;\n      } else if (v.constructor === XNumber) {\n        t = XPathResult.NUMBER_TYPE;\n      } else if (v.constructor === XBoolean) {\n        t = XPathResult.BOOLEAN_TYPE;\n      } else if (v.constructor === XNodeSet) {\n        t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    }\n    this.resultType = t;\n    switch (t) {\n      case XPathResult.NUMBER_TYPE:\n        this.numberValue = v.numberValue();\n        return;\n      case XPathResult.STRING_TYPE:\n        this.stringValue = v.stringValue();\n        return;\n      case XPathResult.BOOLEAN_TYPE:\n        this.booleanValue = v.booleanValue();\n        return;\n      case XPathResult.ANY_UNORDERED_NODE_TYPE:\n      case XPathResult.FIRST_ORDERED_NODE_TYPE:\n        if (v.constructor === XNodeSet) {\n          this.singleNodeValue = v.first();\n          return;\n        }\n        break;\n      case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:\n      case XPathResult.ORDERED_NODE_ITERATOR_TYPE:\n        if (v.constructor === XNodeSet) {\n          this.invalidIteratorState = false;\n          this.nodes = v.toArray();\n          this.iteratorIndex = 0;\n          return;\n        }\n        break;\n      case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:\n      case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:\n        if (v.constructor === XNodeSet) {\n          this.nodes = v.toArray();\n          this.snapshotLength = this.nodes.length;\n          return;\n        }\n        break;\n    }\n    throw new XPathException(XPathException.TYPE_ERR);\n  }\n  ;\n  XPathResult.prototype.iterateNext = function () {\n    if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n      throw new XPathException(XPathException.TYPE_ERR);\n    }\n    return this.nodes[this.iteratorIndex++];\n  };\n  XPathResult.prototype.snapshotItem = function (i) {\n    if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {\n      throw new XPathException(XPathException.TYPE_ERR);\n    }\n    return this.nodes[i];\n  };\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n\n  // DOM 3 XPath support ///////////////////////////////////////////////////////\n\n  function installDOM3XPathSupport(doc, p) {\n    doc.createExpression = function (e, r) {\n      try {\n        return new XPathExpression(e, r, p);\n      } catch (e) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);\n      }\n    };\n    doc.createNSResolver = function (n) {\n      return new NodeXPathNSResolver(n);\n    };\n    doc.evaluate = function (e, cn, r, t, res) {\n      if (t < 0 || t > 9) {\n        throw {\n          code: 0,\n          toString: function toString() {\n            return \"Request type not supported\";\n          }\n        };\n      }\n      return doc.createExpression(e, r, p).evaluate(cn, t, res);\n    };\n  }\n  ;\n\n  // ---------------------------------------------------------------------------\n\n  // Install DOM 3 XPath support for the current document.\n  try {\n    var shouldInstall = true;\n    try {\n      if (document.implementation && document.implementation.hasFeature && document.implementation.hasFeature(\"XPath\", null)) {\n        shouldInstall = false;\n      }\n    } catch (e) {}\n    if (shouldInstall) {\n      installDOM3XPathSupport(document, new XPathParser());\n    }\n  } catch (e) {}\n\n  // ---------------------------------------------------------------------------\n  // exports for node.js\n\n  installDOM3XPathSupport(exports, new XPathParser());\n  (function () {\n    var parser = new XPathParser();\n    var defaultNSResolver = new NamespaceResolver();\n    var defaultFunctionResolver = new FunctionResolver();\n    var defaultVariableResolver = new VariableResolver();\n    function makeNSResolverFromFunction(func) {\n      return {\n        getNamespace: function getNamespace(prefix, node) {\n          var ns = func(prefix, node);\n          return ns || defaultNSResolver.getNamespace(prefix, node);\n        }\n      };\n    }\n    function makeNSResolverFromObject(obj) {\n      return makeNSResolverFromFunction(obj.getNamespace.bind(obj));\n    }\n    function makeNSResolverFromMap(map) {\n      return makeNSResolverFromFunction(function (prefix) {\n        return map[prefix];\n      });\n    }\n    function makeNSResolver(resolver) {\n      if (resolver && typeof resolver.getNamespace === \"function\") {\n        return makeNSResolverFromObject(resolver);\n      }\n      if (typeof resolver === \"function\") {\n        return makeNSResolverFromFunction(resolver);\n      }\n\n      // assume prefix -> uri mapping\n      if (_typeof(resolver) === \"object\") {\n        return makeNSResolverFromMap(resolver);\n      }\n      return defaultNSResolver;\n    }\n\n    /** Converts native JavaScript types to their XPath library equivalent */\n    function convertValue(value) {\n      if (value === null || typeof value === \"undefined\" || value instanceof XString || value instanceof XBoolean || value instanceof XNumber || value instanceof XNodeSet) {\n        return value;\n      }\n      switch (_typeof(value)) {\n        case \"string\":\n          return new XString(value);\n        case \"boolean\":\n          return new XBoolean(value);\n        case \"number\":\n          return new XNumber(value);\n      }\n\n      // assume node(s)\n      var ns = new XNodeSet();\n      ns.addArray([].concat(value));\n      return ns;\n    }\n    function makeEvaluator(func) {\n      return function (context) {\n        var args = Array.prototype.slice.call(arguments, 1).map(function (arg) {\n          return arg.evaluate(context);\n        });\n        var result = func.apply(this, [].concat(context, args));\n        return convertValue(result);\n      };\n    }\n    function makeFunctionResolverFromFunction(func) {\n      return {\n        getFunction: function getFunction(name, namespace) {\n          var found = func(name, namespace);\n          if (found) {\n            return makeEvaluator(found);\n          }\n          return defaultFunctionResolver.getFunction(name, namespace);\n        }\n      };\n    }\n    function makeFunctionResolverFromObject(obj) {\n      return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));\n    }\n    function makeFunctionResolverFromMap(map) {\n      return makeFunctionResolverFromFunction(function (name) {\n        return map[name];\n      });\n    }\n    function makeFunctionResolver(resolver) {\n      if (resolver && typeof resolver.getFunction === \"function\") {\n        return makeFunctionResolverFromObject(resolver);\n      }\n      if (typeof resolver === \"function\") {\n        return makeFunctionResolverFromFunction(resolver);\n      }\n\n      // assume map\n      if (_typeof(resolver) === \"object\") {\n        return makeFunctionResolverFromMap(resolver);\n      }\n      return defaultFunctionResolver;\n    }\n    function makeVariableResolverFromFunction(func) {\n      return {\n        getVariable: function getVariable(name, namespace) {\n          var value = func(name, namespace);\n          return convertValue(value);\n        }\n      };\n    }\n    function makeVariableResolver(resolver) {\n      if (resolver) {\n        if (typeof resolver.getVariable === \"function\") {\n          return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));\n        }\n        if (typeof resolver === \"function\") {\n          return makeVariableResolverFromFunction(resolver);\n        }\n\n        // assume map\n        if (_typeof(resolver) === \"object\") {\n          return makeVariableResolverFromFunction(function (name) {\n            return resolver[name];\n          });\n        }\n      }\n      return defaultVariableResolver;\n    }\n    function makeContext(options) {\n      var context = new XPathContext();\n      if (options) {\n        context.namespaceResolver = makeNSResolver(options.namespaces);\n        context.functionResolver = makeFunctionResolver(options.functions);\n        context.variableResolver = makeVariableResolver(options.variables);\n        context.expressionContextNode = options.node;\n      } else {\n        context.namespaceResolver = defaultNSResolver;\n      }\n      return context;\n    }\n    function _evaluate(parsedExpression, options) {\n      var context = makeContext(options);\n      return parsedExpression.evaluate(context);\n    }\n    var evaluatorPrototype = {\n      evaluate: function evaluate(options) {\n        return _evaluate(this.expression, options);\n      },\n      evaluateNumber: function evaluateNumber(options) {\n        return this.evaluate(options).numberValue();\n      },\n      evaluateString: function evaluateString(options) {\n        return this.evaluate(options).stringValue();\n      },\n      evaluateBoolean: function evaluateBoolean(options) {\n        return this.evaluate(options).booleanValue();\n      },\n      evaluateNodeSet: function evaluateNodeSet(options) {\n        return this.evaluate(options).nodeset();\n      },\n      select: function select(options) {\n        return this.evaluateNodeSet(options).toArray();\n      },\n      select1: function select1(options) {\n        return this.select(options)[0];\n      }\n    };\n    function parse(xpath) {\n      var parsed = parser.parse(xpath);\n      return Object.create(evaluatorPrototype, {\n        expression: {\n          value: parsed\n        }\n      });\n    }\n    exports.parse = parse;\n  })();\n  exports.XPath = XPath;\n  exports.XPathParser = XPathParser;\n  exports.XPathResult = XPathResult;\n  exports.Step = Step;\n  exports.NodeTest = NodeTest;\n  exports.BarOperation = BarOperation;\n  exports.NamespaceResolver = NamespaceResolver;\n  exports.FunctionResolver = FunctionResolver;\n  exports.VariableResolver = VariableResolver;\n  exports.Utilities = Utilities;\n  exports.XPathContext = XPathContext;\n  exports.XNodeSet = XNodeSet;\n  exports.XBoolean = XBoolean;\n  exports.XString = XString;\n  exports.XNumber = XNumber;\n\n  // helper\n  exports.select = function (e, doc, single) {\n    return exports.selectWithResolver(e, doc, null, single);\n  };\n  exports.useNamespaces = function (mappings) {\n    var resolver = {\n      mappings: mappings || {},\n      lookupNamespaceURI: function lookupNamespaceURI(prefix) {\n        return this.mappings[prefix];\n      }\n    };\n    return function (e, doc, single) {\n      return exports.selectWithResolver(e, doc, resolver, single);\n    };\n  };\n  exports.selectWithResolver = function (e, doc, resolver, single) {\n    var expression = new XPathExpression(e, resolver, new XPathParser());\n    var type = XPathResult.ANY_TYPE;\n    var result = expression.evaluate(doc, type, null);\n    if (result.resultType == XPathResult.STRING_TYPE) {\n      result = result.stringValue;\n    } else if (result.resultType == XPathResult.NUMBER_TYPE) {\n      result = result.numberValue;\n    } else if (result.resultType == XPathResult.BOOLEAN_TYPE) {\n      result = result.booleanValue;\n    } else {\n      result = result.nodes;\n      if (single) {\n        result = result[0];\n      }\n    }\n    return result;\n  };\n  exports.select1 = function (e, doc) {\n    return exports.select(e, doc, true);\n  };\n\n  // end non-node wrapper\n})(xpath);\n\n//# sourceURL=webpack://ogcparser/./node_modules/xpath/xpath.js?");

/***/ }),

/***/ "./src/service.js":
/*!************************!*\
  !*** ./src/service.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var xpath = __webpack_require__(/*! xpath */ \"./node_modules/xpath/xpath.js\");\nvar createDocument = (__webpack_require__(/*! ./utils */ \"./src/utils.js\").createDocument);\n\n// Use OGC namespace\nvar select = xpath.useNamespaces({\n  'ows': 'http://www.opengis.net/ows/1.1',\n  'xlink': 'http://www.w3.org/1999/xlink'\n});\n\n/**\n * @typedef {[number, number, number, number]} BBox\n */\n\n/**\n * @typedef {('OGC WMTS'|'OGC WMS')} ServiceType\n */\n\n/**\n * @typedef {('1.0.0'|'1.3.0'|'1.1.0'|'1.1.1')} ServiceVersion\n */\n\n/**\n * OGC Service\n *\n * @typedef {Object} Service\n * @property {ServiceType} type\n * @property {ServiceVersion} version\n * @property {string} title\n */\n\n/**\n * Parse OGC Service\n *\n * @param {string|Document} xml\n * @returns {Service} OGC Service\n */\nmodule.exports = function (xml) {\n  var doc = createDocument(xml);\n  var type;\n  var version;\n  var title;\n\n  // WMS 1.0 & 1.1\n  if (select('//WMT_MS_Capabilities', doc).length) {\n    type = 'OGC WMS';\n    version = select('string(//WMT_MS_Capabilities/@version)', doc, true);\n    title = select('string(//Service/Title)', doc, true);\n    // WMS 1.3\n  } else if (select('//WMS_Capabilities', doc).length) {\n    type = 'OGC WMS';\n    version = select('string(//WMS_Capabilities/@version)', doc, true);\n    title = select('string(//Service/Title)', doc, true);\n    // WMTS\n  } else {\n    type = select('string(//ows:ServiceType)', doc, true);\n    version = select('string(//ows:ServiceTypeVersion)', doc, true);\n    title = select('string(//ows:Title)', doc, true);\n  }\n  return {\n    type: type || null,\n    version: version || null,\n    title: title || null\n  };\n};\n\n//# sourceURL=webpack://ogcparser/./src/service.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar DOMParser = (__webpack_require__(/*! xmldom */ \"./node_modules/xmldom/dom-parser.js\").DOMParser);\n\n/**\n * Create Document\n *\n * @param {string|Document} xml\n * @returns {Document} DOM Document\n */\nfunction createDocument(xml) {\n  if (_typeof(xml) === 'object') return xml;\n  if (typeof xml !== 'string') throw new Error('xml must be a string or Document');\n  xml = xml.replace(/xmlns=\"[\\S]+\"/, '');\n  return new DOMParser().parseFromString(xml);\n}\nmodule.exports = {\n  createDocument: createDocument\n};\n\n//# sourceURL=webpack://ogcparser/./src/utils.js?");

/***/ }),

/***/ "./src/wms.js":
/*!********************!*\
  !*** ./src/wms.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var xpath = __webpack_require__(/*! xpath */ \"./node_modules/xpath/xpath.js\");\nvar URL = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\nvar service = __webpack_require__(/*! ./service */ \"./src/service.js\");\nvar createDocument = (__webpack_require__(/*! ./utils */ \"./src/utils.js\").createDocument);\n\n// Use OGC namespace\nvar select = xpath.useNamespaces({\n  'ows': 'http://www.opengis.net/ows/1.1',\n  'xlink': 'http://www.w3.org/1999/xlink'\n});\n\n/**\n * @typedef {'png'|'jpg'} Format\n */\n\n/**\n * @typedef {[number, number, number, number]} BBox\n */\n\n/**\n * @typedef {('OGC WMTS'|'OGC WMS')} ServiceType\n */\n\n/**\n * @typedef {('1.0.0'|'1.3.0'|'1.1.0'|'1.1.1')} ServiceVersion\n */\n\n/**\n * WMS Metadata\n *\n * @typedef {Object} Metadata\n * @property {Layer} layer\n * @property {Service} service\n * @property {URL} url\n */\n\n/**\n * WMS Metadata.Layer\n *\n * @typedef {Object} Layer\n * @property {string} title\n * @property {string} identifier\n * @property {Format} format\n * @property {string[]} formats\n * @property {string} abstract\n * @property {number} minzoom\n * @property {number} maxzoom\n * @property {BBox} bbox\n */\n\n/**\n * WMS Metadata.Service\n *\n * @typedef {Object} Service\n * @property {string} type\n * @property {string} version\n * @property {string} title\n */\n\n/**\n* WMS Metadata.Layer.URL\n*\n* @typedef {Object} URL\n* @property {string} onlineResource\n* @property {string} getCapabilities\n* @property {string} slippy\n* @property {string} host\n*/\n\n/**\n * Select BBox\n *\n * @param {Document} doc\n * @returns {BBox} BBox\n */\nfunction selectBBox(doc) {\n  var west;\n  var south;\n  var east;\n  var north;\n\n  // WMS 1.1\n  // <LatLonBoundingBox minx=\"-141\" miny=\"41\" maxx=\"-52\" maxy=\"84\" />\n  if (select('//LatLonBoundingBox', doc).length) {\n    west = select('string(//LatLonBoundingBox/@minx)', doc, true);\n    south = select('string(//LatLonBoundingBox/@miny)', doc, true);\n    east = select('string(//LatLonBoundingBox/@maxx)', doc, true);\n    north = select('string(//LatLonBoundingBox/@maxy)', doc, true);\n    // WMS 1.3\n    // <BoundingBox CRS=\"CRS:84\" minx=\"-71.63\" miny=\"41.75\" maxx=\"-70.78\" maxy=\"42.90\" resx=\"0.01\" resy=\"0.01\"/>\n  } else if (select('//BoundingBox', doc).length) {\n    west = select('string(//BoundingBox[@CRS=\"CRS:84\"]/@minx)', doc, true);\n    south = select('string(//BoundingBox[@CRS=\"CRS:84\"]/@miny)', doc, true);\n    east = select('string(//BoundingBox[@CRS=\"CRS:84\"]/@maxx)', doc, true);\n    north = select('string(//BoundingBox[@CRS=\"CRS:84\"]/@maxy)', doc, true);\n  }\n  if (south && west && north && east) {\n    return [Number(west), Number(south), Number(east), Number(north)];\n  }\n  return null;\n}\n\n/**\n * Parse Layer\n *\n * @param {Document} doc\n * @returns {Layer} layer\n */\nfunction layer(doc) {\n  var title = select('string(//Service/Title)', doc, true);\n  var identifier = select('string(//Layer/Name)', doc, true);\n  var _abstract = select('string(//Service/Abstract)', doc, true);\n  var bbox = selectBBox(doc);\n\n  // WMS 1.1 & 1.3\n  var formats = select('//GetMap/Format', doc).map(function (format) {\n    return format.textContent;\n  });\n\n  // WMS 1.0\n  if (select('//Format/PNG', doc, true)) formats.push('image/png');\n  if (select('//Format/JPEG', doc, true)) formats.push('image/jpeg');\n  var format;\n  if (formats.indexOf('image/png') !== -1) format = 'png';else if (formats.indexOf('image/jpeg') !== -1) format = 'jpg';\n  return {\n    title: title || null,\n    \"abstract\": _abstract || null,\n    identifier: identifier || null,\n    format: format || null,\n    formats: formats,\n    bbox: bbox,\n    minzoom: 0,\n    maxzoom: 19\n  };\n}\n\n/**\n * Parse URL\n *\n * @param {Document} doc\n * @returns {URL} url\n */\nfunction url(doc) {\n  var onlineResource = select('string(//OnlineResource/@xlink:href)', doc, true);\n  var version = service(doc).version;\n  var url = URL.parse(onlineResource);\n\n  // Create Slippy URL\n  var slippy;\n  var getCapabilities;\n  if (onlineResource) {\n    url.search = null;\n    url.query = {\n      service: 'WMS',\n      request: 'GetMap',\n      version: version,\n      layers: '{Layer}',\n      transparent: 'false',\n      format: '{format}',\n      height: '{height}',\n      width: '{width}',\n      srs: '{srs}',\n      bbox: '{bbox}'\n    };\n    slippy = URL.format(url).replace(/%7B/g, '{').replace(/%7D/g, '}');\n\n    // Create RESTful GetCapabilities\n    url.query = {\n      service: 'WMS',\n      request: 'GetCapabilities',\n      version: version\n    };\n    getCapabilities = URL.format(url).replace(/%7B/g, '{').replace(/%7D/g, '}');\n  }\n  return {\n    slippy: slippy || null,\n    onlineResource: onlineResource || null,\n    getCapabilities: getCapabilities || null,\n    host: url.host\n  };\n}\n\n/**\n * Parse Capabilities\n *\n * @param {string|Document} xml\n * @returns {Metadata} WMS Metadata\n */\nmodule.exports = function (xml) {\n  var doc = createDocument(xml);\n  return {\n    service: service(doc),\n    layer: layer(doc),\n    url: url(doc)\n  };\n};\n\n//# sourceURL=webpack://ogcparser/./src/wms.js?");

/***/ }),

/***/ "./src/wmts.js":
/*!*********************!*\
  !*** ./src/wmts.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var xpath = __webpack_require__(/*! xpath */ \"./node_modules/xpath/xpath.js\");\nvar URL = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\nvar service = __webpack_require__(/*! ./service */ \"./src/service.js\");\nvar createDocument = (__webpack_require__(/*! ./utils */ \"./src/utils.js\").createDocument);\nvar zoomLevels = __webpack_require__(/*! ./zoom-levels */ \"./src/zoom-levels.js\");\n\n// Use OGC namespace\nvar select = xpath.useNamespaces({\n  'ows': 'http://www.opengis.net/ows/1.1',\n  'xlink': 'http://www.w3.org/1999/xlink'\n});\n\n/**\n * @typedef {'png'|'jpg'} Format\n */\n\n/**\n * @typedef {[number, number, number, number]} BBox\n */\n\n/**\n * @typedef {'OGC WMTS'|'OGC WMS'} ServiceType\n */\n\n/**\n * @typedef {'1.0.0'|'1.3.0'} ServiceVersion\n */\n\n/**\n * WMTS Metadata\n *\n * @typedef {Object} Metadata\n * @property {Layer} layer\n * @property {Service} service\n * @property {URL} url\n */\n\n/**\n * WMTS Metadata.Layer\n *\n * @typedef {Object} Layer\n * @property {string} title\n * @property {string} identifier\n * @property {Format} format\n * @property {string[]} formats\n * @property {string} abstract\n * @property {number} minzoom\n * @property {number} maxzoom\n * @property {BBox} bbox\n * @property {string[]} tileMatrixSets\n */\n\n/**\n * WMTS Metadata.Service\n *\n * @typedef {Object} Service\n * @property {string} type\n * @property {string} version\n * @property {string} title\n */\n\n/**\n * WMTS Metadata.Layer.URL\n *\n * @typedef {Object} URL\n * @property {string} getCapabilities\n * @property {string} getTile\n * @property {string} resourceURL\n * @property {string} slippy\n * @property {string} host\n */\n\n/**\n * Select BBox\n *\n * @param {Document} node\n * @returns {BBox} BBox\n */\nfunction selectBBox(node) {\n  var southwest = select('string(//ows:WGS84BoundingBox//ows:LowerCorner)', node, true);\n  var northeast = select('string(//ows:WGS84BoundingBox//ows:UpperCorner)', node, true);\n  if (southwest && northeast) {\n    southwest = southwest.split(' ');\n    northeast = northeast.split(' ');\n    return [Number(southwest[0]), Number(southwest[1]), Number(northeast[0]), Number(northeast[1])];\n  }\n  return null;\n}\n\n/**\n * Parse Contents Layer\n *\n * @param {Document} \n * @returns {Layer} layer[]\n */\nfunction layers(doc) {\n  var out = [];\n  var layers = select('//Contents/Layer', doc);\n  layers.forEach(function (l) {\n    out.push(layer(l));\n  });\n  return out;\n}\n\n/**\n * Parse Layer\n *\n * @param {Document} doc\n * @returns {Layer} layer\n */\nfunction layer(doc) {\n  var title = select('string(./ows:Title)', doc, true);\n  var identifier = select('string(./ows:Identifier)', doc, true);\n  var _abstract = select('string(./ows:Abstract)', doc, true);\n  var formats = select('./Format', doc).map(function (format) {\n    return format.textContent;\n  });\n  var bbox = selectBBox(doc);\n  var zooms = zoomLevels(doc);\n  var tileMatrixSets = zooms.tileMatrixSets;\n  var maxzoom = zooms.maxzoom;\n  var minzoom = zooms.minzoom;\n  var format;\n  if (formats.indexOf('image/png') !== -1) format = 'png';else if (formats.indexOf('image/jpeg') !== -1) format = 'jpg';\n  return {\n    title: title || null,\n    \"abstract\": _abstract || null,\n    identifier: identifier || null,\n    format: format || null,\n    formats: formats,\n    bbox: bbox,\n    minzoom: minzoom,\n    maxzoom: maxzoom,\n    tileMatrixSets: tileMatrixSets\n  };\n}\n\n/**\n * Parse URL\n *\n * @param {Document} doc\n * @returns {URL} url\n */\nfunction url(doc) {\n  var resourceURL = select('string(//ResourceURL/@template)', doc, true);\n  var getTile = select('string(//ows:Operation[@name=\"GetTile\"]//ows:Get/@xlink:href)', doc, true);\n  var getCapabilities = select('string(//ows:Operation[@name=\"GetCapabilities\"]//ows:Get/@xlink:href)', doc, true);\n  if (!getCapabilities) getCapabilities = select('string(//ServiceMetadataURL/@xlink:href)', doc, true);\n  var parse = URL.parse(getCapabilities);\n\n  // Create Resource URL from KVP params\n  var slippy = resourceURL;\n  if (resourceURL === '' && getTile) {\n    var kvp = URL.parse(getTile);\n    kvp.search = null;\n    kvp.query = {\n      service: 'wmts',\n      request: 'getTile',\n      version: '1.0.0',\n      layer: '{Layer}',\n      style: '{Style}',\n      tilematrixset: '{TileMatrixSet}',\n      tilematrix: '{TileMatrix}',\n      tilerow: '{TileRow}',\n      tilecol: '{TileCol}',\n      format: '{Format}'\n    };\n    slippy = URL.format(kvp).replace(/%7B/g, '{').replace(/%7D/g, '}');\n  }\n  return {\n    slippy: slippy || null,\n    resourceURL: resourceURL || null,\n    getCapabilities: getCapabilities || null,\n    getTile: getTile || null,\n    host: parse.host\n  };\n}\n\n/**\n * Parse Capabilities\n *\n * @param {string|Document} xml\n * @returns {Metadata} WMTS Metadata\n */\nmodule.exports = function (xml) {\n  var doc = createDocument(xml);\n  return {\n    service: service(doc),\n    layer: layers(doc),\n    url: url(doc)\n  };\n};\n\n//# sourceURL=webpack://ogcparser/./src/wmts.js?");

/***/ }),

/***/ "./src/zoom-levels.js":
/*!****************************!*\
  !*** ./src/zoom-levels.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var xpath = __webpack_require__(/*! xpath */ \"./node_modules/xpath/xpath.js\");\nvar createDocument = (__webpack_require__(/*! ./utils */ \"./src/utils.js\").createDocument);\n\n// Use OGC namespace\nvar select = xpath.useNamespaces({\n  'ows': 'http://www.opengis.net/ows/1.1',\n  'xlink': 'http://www.w3.org/1999/xlink'\n});\n\n/**\n * Mapbox\n * ------\n * <TileMatrixSet>\n * <ows:Title>GoogleMapsCompatible</ows:Title>\n * <ows:Abstract>GoogleMapsCompatible EPSG:3857</ows:Abstract>\n * <ows:Identifier>GoogleMapsCompatible</ows:Identifier>\n * <ows:SupportedCRS>urn:ogc:def:crs:EPSG::3857</ows:SupportedCRS>\n * <TileMatrix>\n *   <ows:Identifier>0</ows:Identifier>\n *   <ScaleDenominator>279541132.0143589</ScaleDenominator>\n *   <TopLeftCorner>-20037508.34278925 20037508.34278925</TopLeftCorner>\n *   <TileWidth>512</TileWidth>\n *   <TileHeight>512</TileHeight>\n *   <MatrixWidth>1</MatrixWidth>\n *   <MatrixHeight>1</MatrixHeight>\n * </TileMatrix>\n * <TileMatrix>\n *   <ows:Identifier>1</ows:Identifier>\n *   <ScaleDenominator>139770566.00717944</ScaleDenominator>\n *   <TopLeftCorner>-20037508.34278925 20037508.34278925</TopLeftCorner>\n *   <TileWidth>512</TileWidth>\n *   <TileHeight>512</TileHeight>\n *   <MatrixWidth>2</MatrixWidth>\n *   <MatrixHeight>2</MatrixHeight>\n *   </TileMatrix>\n *\n * GeoServer\n * ---------\n * <TileMatrixSet>\n *   <ows:Identifier>EPSG:900913</ows:Identifier>\n *   <ows:SupportedCRS>urn:ogc:def:crs:EPSG::900913</ows:SupportedCRS>\n *   <TileMatrix>\n *     <ows:Identifier>EPSG:900913:0</ows:Identifier>\n *     <ScaleDenominator>5.590822639508929E8</ScaleDenominator>\n *     <TopLeftCorner>-2.003750834E7 2.0037508E7</TopLeftCorner>\n *     <TileWidth>256</TileWidth>\n *     <TileHeight>256</TileHeight>\n *     <MatrixWidth>1</MatrixWidth>\n *     <MatrixHeight>1</MatrixHeight>\n *   </TileMatrix>\n *   <TileMatrix>\n *     <ows:Identifier>EPSG:900913:1</ows:Identifier>\n *     <ScaleDenominator>2.7954113197544646E8</ScaleDenominator>\n *     <TopLeftCorner>-2.003750834E7 2.0037508E7</TopLeftCorner>\n *     <TileWidth>256</TileWidth>\n *     <TileHeight>256</TileHeight>\n *     <MatrixWidth>2</MatrixWidth>\n *     <MatrixHeight>2</MatrixHeight>\n *   </TileMatrix>\n *\n * ArcGIS\n * ------\n * <TileMatrixSet>\n *   <ows:Title>GoogleMapsCompatible</ows:Title>\n *   <ows:Abstract>the wellknown 'GoogleMapsCompatible' tile matrix set defined by OGC WMTS specification</ows:Abstract>\n *   <ows:Identifier>GoogleMapsCompatible</ows:Identifier>\n *   <ows:SupportedCRS>urn:ogc:def:crs:EPSG:6.18.3:3857</ows:SupportedCRS>\n *   <WellKnownScaleSet>urn:ogc:def:wkss:OGC:1.0:GoogleMapsCompatible</WellKnownScaleSet>\n *   <TileMatrix>\n *     <ows:Identifier>0</ows:Identifier>\n *     <ScaleDenominator>559082264.0287178</ScaleDenominator>\n *     <TopLeftCorner>-20037508.34278925 20037508.34278925</TopLeftCorner>\n *     <TileWidth>256</TileWidth>\n *     <TileHeight>256</TileHeight>\n *     <MatrixWidth>1</MatrixWidth>\n *     <MatrixHeight>1</MatrixHeight>\n *   </TileMatrix>\n *   <TileMatrix>\n *     <ows:Identifier>1</ows:Identifier>\n *     <ScaleDenominator>279541132.0143589</ScaleDenominator>\n *     <TopLeftCorner>-20037508.34278925 20037508.34278925</TopLeftCorner>\n *     <TileWidth>256</TileWidth>\n *     <TileHeight>256</TileHeight>\n *     <MatrixWidth>2</MatrixWidth>\n *     <MatrixHeight>2</MatrixHeight>\n *   </TileMatrix>\n */\n\n/**\n* WMTS Zoom Levels\n*\n* @typedef {Object} Zooms\n* @property {number} minzoom\n* @property {number} maxzoom\n* @property {string[]} tileMatrixSets\n*/\n\n/**\n * Parse WMTS Zoom Levels\n *\n * @param {string|Document} xml\n * @returns {Zooms} WMTS Zoom Levels\n */\nmodule.exports = function (xml) {\n  var doc = createDocument(xml);\n  var tileMatrix = [];\n  var minzoom;\n  var maxzoom;\n  var tileMatrixSets = select('//TileMatrixSet/ows:Identifier', doc).map(function (tileMatrixSet) {\n    return tileMatrixSet.textContent;\n  });\n\n  // Support GoogleMapsCompatible\n  select('//TileMatrixSet[ows:Identifier=\"GoogleMapsCompatible\"]/./TileMatrix/ows:Identifier', doc).forEach(function (TileMatrix) {\n    var identifier = TileMatrix.textContent;\n    tileMatrix.push(identifier);\n    var zoom = Number(identifier);\n    if (zoom <= minzoom || minzoom === undefined) minzoom = zoom;\n    if (zoom >= maxzoom || maxzoom === undefined) maxzoom = zoom;\n  });\n  // Support EPSG:900913 (Google Projection)\n  select('//TileMatrixSet[ows:Identifier=\"EPSG:900913\"]/./TileMatrix/ows:Identifier', doc).forEach(function (TileMatrix) {\n    var identifier = TileMatrix.textContent;\n    tileMatrix.push(identifier);\n    var zoom = Number(identifier.replace('EPSG:900913:', ''));\n    if (zoom < minzoom || minzoom === undefined) minzoom = zoom;\n    if (zoom > maxzoom || maxzoom === undefined) maxzoom = zoom;\n  });\n  return {\n    // tileMatrix: tileMatrix,\n    tileMatrixSets: tileMatrixSets,\n    minzoom: minzoom !== undefined ? minzoom : null,\n    maxzoom: maxzoom !== undefined ? maxzoom : null\n  };\n};\n\n//# sourceURL=webpack://ogcparser/./src/zoom-levels.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	ogcparser = __webpack_exports__;
/******/ 	
/******/ })()
;